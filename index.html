<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Wallet Tracker</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&family=Playfair+Display:wght@400;700&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { min-height: 100vh; background: #1a0a0a; color: #fff; font-family: 'Courier Prime', monospace; position: relative; }
    .bg-pattern { position: fixed; inset: 0; opacity: 0.02; background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 30L30 60L0 30L30 0z' fill='%23ff0000' fill-opacity='1'/%3E%3C/svg%3E"); background-size: 30px 30px; }
    .container { position: relative; z-index: 10; max-width: 900px; margin: 0 auto; padding: 48px 24px; }
    header { text-align: center; margin-bottom: 48px; border-bottom: 2px solid #8b0000; padding-bottom: 32px; }
    .ornament { color: #ff6666; font-size: 24px; letter-spacing: 8px; margin-bottom: 16px; }
    h1 { font-family: 'Playfair Display', serif; font-size: 3rem; font-weight: 700; color: #ff4444; text-shadow: 2px 2px 0px #4a0000, 0 0 30px rgba(255, 68, 68, 0.4); letter-spacing: 4px; text-transform: uppercase; margin-bottom: 8px; }
    .subtitle { color: #f5f5f5; font-size: 1rem; letter-spacing: 3px; text-transform: uppercase; }
    .total-card { position: relative; padding: 32px; margin-bottom: 40px; background: linear-gradient(135deg, #2a1010 0%, #1a0808 100%); border: 2px solid #6b2222; box-shadow: inset 0 0 30px rgba(139, 0, 0, 0.2), 0 0 20px rgba(139, 0, 0, 0.1); }
    .total-card::before { content: ''; position: absolute; top: 8px; left: 8px; right: 8px; bottom: 8px; border: 1px solid #4a1a1a; pointer-events: none; }
    .corner { position: absolute; width: 20px; height: 20px; border-color: #ff6666; border-style: solid; }
    .corner-tl { top: -2px; left: -2px; border-width: 3px 0 0 3px; }
    .corner-tr { top: -2px; right: -2px; border-width: 3px 3px 0 0; }
    .corner-bl { bottom: -2px; left: -2px; border-width: 0 0 3px 3px; }
    .corner-br { bottom: -2px; right: -2px; border-width: 0 3px 3px 0; }
    .total-label { color: #ffffff; font-size: 14px; text-transform: uppercase; letter-spacing: 4px; margin-bottom: 8px; }
    .total-value { display: flex; align-items: baseline; gap: 8px; justify-content: center; }
    .total-amount { font-family: 'VT323', monospace; font-size: 4rem; color: #ff4444; text-shadow: 0 0 20px rgba(255, 68, 68, 0.5), 0 0 40px rgba(255, 68, 68, 0.3); letter-spacing: 2px; }
    .total-currency { font-size: 1.5rem; color: #ffaaaa; }
    .last-updated { color: #f0f0f0; font-size: 14px; margin-top: 16px; text-align: center; font-style: italic; }
    .refresh-container { display: flex; justify-content: center; margin-bottom: 40px; }
    .refresh-btn { display: flex; align-items: center; gap: 12px; padding: 14px 32px; background: linear-gradient(180deg, #3d1515 0%, #2a0a0a 100%); border: 2px solid #ff6666; color: #ffffff; font-family: 'Courier Prime', monospace; font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 0 #4a0000, 0 0 20px rgba(139, 0, 0, 0.2); }
    .refresh-btn:hover { background: linear-gradient(180deg, #4a1a1a 0%, #3d1010 100%); box-shadow: 0 4px 0 #4a0000, 0 0 30px rgba(196, 30, 58, 0.4); }
    .refresh-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #4a0000; }
    .refresh-btn:disabled { cursor: not-allowed; opacity: 0.5; }
    .refresh-icon { width: 18px; height: 18px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinning { animation: spin 1s linear infinite; }
    .section-title { font-family: 'Playfair Display', serif; font-size: 1.5rem; color: #ff6666; text-align: center; margin: 40px 0 24px; padding-bottom: 12px; border-bottom: 1px solid #4a1515; text-transform: uppercase; letter-spacing: 3px; }
    .wallets { display: flex; flex-direction: column; gap: 16px; }
    .wallet-card { position: relative; padding: 20px 24px; background: linear-gradient(135deg, #251010 0%, #1a0808 100%); border: 1px solid #5a2020; transition: all 0.3s; }
    .wallet-card:hover { border-color: #aa3333; box-shadow: 0 0 20px rgba(170, 51, 51, 0.3), inset 0 0 30px rgba(139, 0, 0, 0.1); }
    .wallet-card::before { content: attr(data-index); position: absolute; top: -1px; left: 20px; background: #1a0a0a; padding: 0 10px; font-family: 'VT323', monospace; font-size: 18px; color: #ff9999; }
    .wallet-inner { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px; }
    .wallet-left { display: flex; align-items: center; gap: 16px; }
    .coin-icon-wrapper { width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; border: 2px solid #6b2222; background: #2a0a0a; }
    .coin-icon { width: 32px; height: 32px; }
    .wallet-info h3 { display: flex; align-items: center; gap: 12px; font-family: 'Playfair Display', serif; font-size: 1.4rem; color: #ffffff; }
    .coin-badge { font-family: 'VT323', monospace; font-size: 18px; padding: 2px 10px; background: #4a1515; border: 1px solid #6b2222; color: #ffaaaa; }
    .wallet-address { color: #f0e0e0; font-size: 14px; font-family: 'VT323', monospace; margin-top: 6px; letter-spacing: 1px; word-break: break-all; }
    .wallet-price { color: #ffffff; font-size: 15px; margin-top: 6px; }
    .api-source { color: #e0d0d0; font-size: 13px; margin-top: 4px; font-style: italic; }
    .wallet-right { text-align: right; }
    .wallet-balance { font-family: 'VT323', monospace; font-size: 2.2rem; color: #ff7777; text-shadow: 0 0 10px rgba(255, 102, 102, 0.4); }
    .wallet-balance-coin { font-size: 1.2rem; color: #ffaaaa; margin-left: 8px; }
    .wallet-usd { color: #ffffff; font-size: 1.15rem; font-family: 'Courier Prime', monospace; }
    .loading-spinner { display: flex; align-items: center; gap: 8px; color: #ffffff; font-family: 'VT323', monospace; font-size: 20px; }
    .spinner { width: 16px; height: 16px; border: 2px solid #4a1515; border-top-color: #ff6666; border-radius: 50%; animation: spin 1s linear infinite; }
    .wallet-error { color: #ff7777; font-size: 18px; font-family: 'VT323', monospace; }
    .withdrawals-container { background: linear-gradient(135deg, #251010 0%, #1a0808 100%); border: 1px solid #5a2020; padding: 16px; }
    .withdrawal-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid #3d1515; flex-wrap: wrap; gap: 10px; }
    .withdrawal-item:last-child { border-bottom: none; }
    .withdrawal-item:hover { background: rgba(255, 102, 102, 0.05); }
    .withdrawal-left { display: flex; align-items: center; gap: 12px; }
    .withdrawal-coin-badge { font-family: 'VT323', monospace; font-size: 16px; padding: 4px 10px; background: #4a1515; border: 1px solid #6b2222; color: #ffaaaa; min-width: 50px; text-align: center; }
    .withdrawal-info { display: flex; flex-direction: column; gap: 2px; }
    .withdrawal-amount { font-family: 'VT323', monospace; font-size: 1.3rem; color: #ff7777; }
    .withdrawal-to { font-family: 'VT323', monospace; font-size: 12px; color: #aa8888; }
    .withdrawal-right { text-align: right; }
    .withdrawal-date { font-family: 'VT323', monospace; font-size: 14px; color: #cc9999; white-space: nowrap; }
    .withdrawal-txid { font-family: 'VT323', monospace; font-size: 11px; color: #886666; }
    .withdrawal-txid a { color: #aa7777; text-decoration: none; }
    .withdrawal-txid a:hover { color: #ffaaaa; }
    .no-withdrawals { text-align: center; padding: 20px; color: #aa8888; font-family: 'VT323', monospace; font-size: 18px; }
    .burn-container { background: linear-gradient(135deg, #251010 0%, #1a0808 100%); border: 1px solid #5a2020; padding: 16px; }
    .burn-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 2px solid #4a1515; margin-bottom: 8px; flex-wrap: wrap; gap: 10px; }
    .burn-wallet-info { display: flex; flex-direction: column; gap: 4px; }
    .burn-wallet-label { font-family: 'Playfair Display', serif; font-size: 1.1rem; color: #ff9966; display: flex; align-items: center; gap: 8px; }
    .burn-wallet-address { font-family: 'VT323', monospace; font-size: 13px; color: #aa8888; word-break: break-all; }
    .burn-wallet-address a { color: #aa8888; text-decoration: none; }
    .burn-wallet-address a:hover { color: #ffaaaa; }
    .burn-total { text-align: right; }
    .burn-total-label { font-family: 'VT323', monospace; font-size: 12px; color: #aa8888; text-transform: uppercase; }
    .burn-total-amount { font-family: 'VT323', monospace; font-size: 1.8rem; color: #ff9966; text-shadow: 0 0 10px rgba(255, 153, 102, 0.4); }
    .burn-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid #3d1515; flex-wrap: wrap; gap: 10px; }
    .burn-item:last-child { border-bottom: none; }
    .burn-item:hover { background: rgba(255, 153, 102, 0.05); }
    .burn-item-left { display: flex; align-items: center; gap: 12px; }
    .burn-badge { font-family: 'VT323', monospace; font-size: 16px; padding: 4px 10px; background: #4a2515; border: 1px solid #6b3322; color: #ffbb99; min-width: 50px; text-align: center; }
    .burn-item-info { display: flex; flex-direction: column; gap: 2px; }
    .burn-amount { font-family: 'VT323', monospace; font-size: 1.3rem; color: #ff9966; }
    .burn-from { font-family: 'VT323', monospace; font-size: 12px; color: #aa8888; }
    .burn-from a { color: #aa8888; text-decoration: none; }
    .burn-from a:hover { color: #ffaaaa; }
    .burn-item-right { text-align: right; }
    .burn-date { font-family: 'VT323', monospace; font-size: 14px; color: #cc9999; white-space: nowrap; }
    .burn-txid { font-family: 'VT323', monospace; font-size: 11px; color: #886666; }
    .burn-txid a { color: #aa7777; text-decoration: none; }
    .burn-txid a:hover { color: #ffaaaa; }
    .no-burns { text-align: center; padding: 20px; color: #aa8888; font-family: 'VT323', monospace; font-size: 18px; }
    .pending-container { background: linear-gradient(135deg, #1a1025 0%, #150a18 100%); border: 1px solid #5a3060; padding: 16px; }
    .pending-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 2px solid #4a2050; margin-bottom: 8px; flex-wrap: wrap; gap: 10px; }
    .pending-info { display: flex; flex-direction: column; gap: 4px; }
    .pending-label { font-family: 'Playfair Display', serif; font-size: 1.1rem; color: #cc99ff; display: flex; align-items: center; gap: 8px; }
    .pending-subtitle { font-family: 'VT323', monospace; font-size: 13px; color: #aa88bb; }
    .pending-total { text-align: right; }
    .pending-total-label { font-family: 'VT323', monospace; font-size: 12px; color: #aa88bb; text-transform: uppercase; }
    .pending-total-amount { font-family: 'VT323', monospace; font-size: 1.8rem; color: #cc99ff; text-shadow: 0 0 10px rgba(204, 153, 255, 0.4); }
    .pending-item { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid #3d2045; flex-wrap: wrap; gap: 10px; }
    .pending-item:last-child { border-bottom: none; }
    .pending-item:hover { background: rgba(204, 153, 255, 0.05); }
    .pending-item-left { display: flex; align-items: center; gap: 12px; }
    .pending-badge { font-family: 'VT323', monospace; font-size: 16px; padding: 4px 10px; background: #3a2045; border: 1px solid #5a3060; color: #ddaaff; min-width: 50px; text-align: center; }
    .pending-item-info { display: flex; flex-direction: column; gap: 2px; }
    .pending-amount { font-family: 'VT323', monospace; font-size: 1.3rem; color: #cc99ff; }
    .pending-coin { font-family: 'VT323', monospace; font-size: 12px; color: #aa88bb; }
    .pending-item-right { text-align: right; }
    .pending-date { font-family: 'VT323', monospace; font-size: 14px; color: #bb99cc; white-space: nowrap; }
    .pending-status { font-family: 'VT323', monospace; font-size: 12px; color: #ff9966; }
    .no-pending { text-align: center; padding: 20px; color: #88dd88; font-family: 'VT323', monospace; font-size: 18px; }
    .all-burned-icon { font-size: 24px; margin-bottom: 8px; }
    .chart-container { margin-top: 20px; padding: 16px; background: rgba(26, 8, 8, 0.8); border: 1px solid #3d1515; border-radius: 4px; }
    .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
    .chart-title { color: #ffaaaa; font-family: 'VT323', monospace; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; }
    .time-range-buttons { display: flex; gap: 6px; }
    .time-btn { padding: 6px 14px; background: #2a0a0a; border: 1px solid #5a2020; color: #cc9999; font-family: 'VT323', monospace; font-size: 16px; cursor: pointer; transition: all 0.2s; text-transform: uppercase; }
    .time-btn:hover { border-color: #aa4444; color: #ffaaaa; }
    .time-btn.active { background: #4a1515; border-color: #ff6666; color: #ffffff; box-shadow: 0 0 10px rgba(255, 102, 102, 0.3); }
    .chart-wrapper { height: 200px; position: relative; }
    .chart-loading { display: flex; align-items: center; justify-content: center; height: 200px; color: #aa7777; font-family: 'VT323', monospace; }
    /* Emissions styles */
    .emissions-container { background: linear-gradient(135deg, #101a25 0%, #08101a 100%); border: 1px solid #205a6b; padding: 16px; margin-bottom: 20px; }
    .emissions-header { display: flex; justify-content: space-between; padding: 12px 16px; border-bottom: 2px solid #154a5a; margin-bottom: 8px; flex-wrap: wrap; gap: 10px; }
    .emissions-label { font-family: 'Playfair Display', serif; font-size: 1.1rem; color: #66ccff; }
    .emissions-subtitle { font-family: 'VT323', monospace; font-size: 13px; color: #88aabb; }
    .emissions-stats { display: flex; gap: 30px; flex-wrap: wrap; }
    .emissions-stat { text-align: right; }
    .emissions-stat-label { font-family: 'VT323', monospace; font-size: 12px; color: #88aabb; text-transform: uppercase; }
    .emissions-stat-amount { font-family: 'VT323', monospace; font-size: 1.5rem; }
    .emissions-chart-container { padding: 16px; background: rgba(8, 16, 26, 0.8); border: 1px solid #154050; border-radius: 4px; margin-top: 12px; }
    .emissions-chart-title { color: #88ccee; font-family: 'VT323', monospace; font-size: 18px; text-transform: uppercase; }
    .emissions-chart-wrapper { height: 300px; position: relative; }
    .emissions-chart-loading { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 300px; color: #88aabb; font-family: 'VT323', monospace; gap: 12px; }
    .emissions-progress { width: 200px; height: 8px; background: #154050; border-radius: 4px; overflow: hidden; }
    .emissions-progress-bar { height: 100%; background: linear-gradient(90deg, #66ccff, #ff9966); width: 0%; transition: width 0.3s; }
    .emissions-legend { display: flex; justify-content: center; gap: 24px; margin-top: 12px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-family: 'VT323', monospace; font-size: 14px; color: #aaccdd; }
    .legend-color { width: 16px; height: 4px; border-radius: 2px; }
    .circulating-container { background: linear-gradient(135deg, #1a2510 0%, #101a08 100%); border: 1px solid #4a6b20; padding: 16px; margin-bottom: 20px; }
    .circulating-header { display: flex; justify-content: space-between; padding: 12px 16px; border-bottom: 2px solid #3a5a14; margin-bottom: 8px; flex-wrap: wrap; gap: 10px; }
    .circulating-label { font-family: 'Playfair Display', serif; font-size: 1.1rem; color: #99ff66; }
    .circulating-subtitle { font-family: 'VT323', monospace; font-size: 13px; color: #88bb88; }
    .circulating-stats { display: flex; gap: 30px; flex-wrap: wrap; }
    .circulating-stat { text-align: right; }
    .circulating-stat-label { font-family: 'VT323', monospace; font-size: 12px; color: #88bb88; text-transform: uppercase; }
    .circulating-stat-amount { font-family: 'VT323', monospace; font-size: 1.5rem; }
    .circulating-chart-container { padding: 16px; background: rgba(16, 26, 8, 0.8); border: 1px solid #3a5014; border-radius: 4px; margin-top: 12px; }
    .circulating-chart-title { color: #88cc88; font-family: 'VT323', monospace; font-size: 18px; text-transform: uppercase; }
    .circulating-chart-wrapper { height: 300px; position: relative; }
    .circulating-chart-loading { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 300px; color: #88bb88; font-family: 'VT323', monospace; gap: 12px; }
    footer { text-align: center; margin-top: 48px; padding-top: 32px; border-top: 1px solid #4a1515; color: #f0e0e0; font-size: 14px; line-height: 2; }
    footer a { color: #ffccaa; text-decoration: none; border-bottom: 1px dotted #ffccaa; }
    footer a:hover { color: #ffffff; }
    .footer-ornament { color: #ff6666; letter-spacing: 4px; margin-bottom: 12px; }
    @media (max-width: 640px) { .container { padding: 24px 12px; } h1 { font-size: 1.8rem; } .total-amount { font-size: 2.2rem; } .wallet-inner { flex-direction: column; align-items: flex-start; } .wallet-right { text-align: left; width: 100%; } .emissions-header, .circulating-header { flex-direction: column; } .emissions-stats, .circulating-stats { width: 100%; justify-content: space-between; } }
  </style>
</head>
<body>
  <div class="bg-pattern"></div>
  <div class="container">
    <header>
      <div class="ornament">‚óÜ ‚óá ‚óÜ ‚óá ‚óÜ</div>
      <h1>Wallet Tracker</h1>
      <p class="subtitle">~ Cryptocurrency Portfolio Monitor ~</p>
    </header>
    <div class="total-card">
      <div class="corner corner-tl"></div><div class="corner corner-tr"></div><div class="corner corner-bl"></div><div class="corner corner-br"></div>
      <p class="total-label">‚óà Total Portfolio Value ‚óà</p>
      <div class="total-value"><span class="total-amount" id="total-usd">$---</span><span class="total-currency">USD</span></div>
      <p class="last-updated" id="last-updated"></p>
      <p class="last-updated" id="next-refresh" style="font-size: 12px; margin-top: 8px; color: #aa8888;"></p>
    </div>
    <div class="refresh-container">
      <button class="refresh-btn" id="refresh-btn" onclick="manualRefresh()">
        <svg class="refresh-icon" id="refresh-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
        <span id="refresh-text">Refresh</span>
      </button>
    </div>
    <h2 class="section-title">‚óà Crypto Wallets ‚óà</h2>
    <div class="wallets" id="wallets"></div>
    <h2 class="section-title">‚óà Recent Withdrawals ‚óà</h2>
    <div class="withdrawals-container" id="withdrawals"><div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Loading withdrawals...</span></div></div>
    <h2 class="section-title">‚è≥ Pending Burns ‚è≥</h2>
    <div class="pending-container" id="pending-burns"><div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Calculating pending burns...</span></div></div>
    <h2 class="section-title">üî• QUAI Burn Wallet Deposits üî• <span id="burn-auto-refresh" style="font-size: 12px; color: #aa8888; font-family: 'VT323', monospace;">(auto-refreshes every 5min)</span></h2>
    <div class="burn-container" id="burn-deposits"><div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Loading burn deposits...</span></div></div>
    <h2 class="section-title">‚óà QUAI Exchange Wallets ‚óà</h2>
    <div class="wallets" id="quai-wallets"></div>

    <h2 class="section-title">üìä QUAI Emissions vs Burns (36hr Lag) üìä</h2>
    <div class="emissions-container">
      <div class="emissions-header">
        <div><div class="emissions-label">‚ö° Network Emissions vs Burns (36hr Lag Corrected)</div><div class="emissions-subtitle" id="emissions-block-range">Block range: Loading...</div></div>
        <div class="emissions-stats">
          <div class="emissions-stat"><div class="emissions-stat-label">Total Emitted</div><div class="emissions-stat-amount" style="color: #66ccff;" id="total-emissions">---</div></div>
          <div class="emissions-stat"><div class="emissions-stat-label">Burns (aligned)</div><div class="emissions-stat-amount" style="color: #ff9966;" id="total-burns-stat">---</div></div>
          <div class="emissions-stat"><div class="emissions-stat-label">Net Supply</div><div class="emissions-stat-amount" style="color: #66ff99;" id="net-supply">---</div></div>
        </div>
      </div>
      <div class="emissions-chart-container">
        <p class="emissions-chart-title">Cumulative Emissions & Burns Over Time (36hr Lag)</p>
        <div class="emissions-chart-wrapper"><canvas id="emissions-chart" style="display: none;"></canvas><div class="emissions-chart-loading" id="emissions-loading"><div class="spinner" style="width: 24px; height: 24px;"></div><span id="emissions-loading-text">Initializing...</span><div class="emissions-progress"><div class="emissions-progress-bar" id="emissions-progress-bar"></div></div></div></div>
        <div class="emissions-legend"><div class="legend-item"><div class="legend-color" style="background: #66ccff;"></div><span>Cumulative Emissions</span></div><div class="legend-item"><div class="legend-color" style="background: #ff9966;"></div><span>Burns (shifted -36hrs)</span></div></div>
      </div>
    </div>

    <h2 class="section-title">üí∞ Circulating Supply (36hr Lag) üí∞</h2>
    <div class="circulating-container">
      <div class="circulating-header">
        <div><div class="circulating-label">üí∞ Circulating Supply (2-week lockup + 36hr lag)</div><div class="circulating-subtitle">Emissions locked for ~241,920 blocks (~2 weeks), burns shifted -36hrs to align</div></div>
        <div class="circulating-stats">
          <div class="circulating-stat"><div class="circulating-stat-label">Unlocked</div><div class="circulating-stat-amount" style="color: #99ff66;" id="unlocked-emissions">---</div></div>
          <div class="circulating-stat"><div class="circulating-stat-label">Burns (aligned)</div><div class="circulating-stat-amount" style="color: #ff9966;" id="circ-total-burns">---</div></div>
          <div class="circulating-stat"><div class="circulating-stat-label">Net Circulating</div><div class="circulating-stat-amount" style="color: #66ffcc;" id="net-circulating">---</div></div>
        </div>
      </div>
      <div class="circulating-chart-container">
        <p class="circulating-chart-title">Unlocked Emissions vs Burns (36hr Lag)</p>
        <div class="circulating-chart-wrapper"><canvas id="circulating-chart" style="display: none;"></canvas><div class="circulating-chart-loading" id="circulating-loading"><div class="spinner" style="width: 24px; height: 24px; border-color: #3a5014; border-top-color: #99ff66;"></div><span>Waiting for emissions data...</span></div></div>
        <div class="emissions-legend"><div class="legend-item"><div class="legend-color" style="background: #99ff66;"></div><span>Unlocked Emissions</span></div><div class="legend-item"><div class="legend-color" style="background: #ff9966;"></div><span>Burns (shifted -36hrs)</span></div></div>
      </div>
    </div>

    <h2 class="section-title">‚è±Ô∏è Aligned Burns (36hr Lag) ‚è±Ô∏è</h2>
    <div class="circulating-container" style="border-color: #4a206b; background: linear-gradient(135deg, #1a1025 0%, #100818 100%);">
      <div class="circulating-header" style="border-color: #4a2060;">
        <div><div class="circulating-label" style="color: #cc99ff;">‚è±Ô∏è Burns Aligned to Unlock Time</div><div class="circulating-subtitle" style="color: #aa88bb;">Burns shifted back ~36hrs (25,920 blocks) to align with when emissions actually hit market</div></div>
        <div class="circulating-stats">
          <div class="circulating-stat"><div class="circulating-stat-label" style="color: #aa88bb;">Unlocked</div><div class="circulating-stat-amount" style="color: #99ff66;" id="aligned-unlocked">---</div></div>
          <div class="circulating-stat"><div class="circulating-stat-label" style="color: #aa88bb;">Burns (aligned)</div><div class="circulating-stat-amount" style="color: #ff9966;" id="aligned-burns">---</div></div>
          <div class="circulating-stat"><div class="circulating-stat-label" style="color: #aa88bb;">Net (aligned)</div><div class="circulating-stat-amount" style="color: #cc99ff;" id="aligned-net">---</div></div>
        </div>
      </div>
      <div class="circulating-chart-container" style="background: rgba(16, 8, 24, 0.8); border-color: #4a2050;">
        <p class="circulating-chart-title" style="color: #aa88cc;">Unlocked vs Burns (36hr Lag Corrected)</p>
        <div class="circulating-chart-wrapper"><canvas id="aligned-chart" style="display: none;"></canvas><div class="circulating-chart-loading" id="aligned-loading" style="color: #aa88bb;"><div class="spinner" style="width: 24px; height: 24px; border-color: #4a2050; border-top-color: #cc99ff;"></div><span>Waiting for emissions data...</span></div></div>
        <div class="emissions-legend"><div class="legend-item"><div class="legend-color" style="background: #99ff66;"></div><span>Unlocked Emissions</span></div><div class="legend-item"><div class="legend-color" style="background: #ff9966;"></div><span>Burns (shifted -36hrs)</span></div><div class="legend-item"><div class="legend-color" style="background: #cc99ff;"></div><span>Net (aligned)</span></div></div>
      </div>
    </div>

    <footer>
      <div class="footer-ornament">‚Äî ‚óÜ ‚Äî</div>
      <p>RVN via <a href="https://cryptoscope.io" target="_blank">CryptoScope</a> ‚Ä¢ BCH via <a href="https://fullstack.cash" target="_blank">FullStack.cash</a></p>
      <p>LTC & DOGE via <a href="https://blockcypher.com" target="_blank">BlockCypher</a> ‚Ä¢ QUAI via <a href="https://rpc.quai.network" target="_blank">Quai RPC</a></p>
      <p>Burn tracking via <a href="https://quaiscan.io" target="_blank">QuaiScan</a> ‚Ä¢ Prices from <a href="https://coingecko.com" target="_blank">CoinGecko</a></p>
    </footer>
  </div>

  <script>
    // ========== ORIGINAL CORS PROXY SETUP (unchanged) ==========
    const CORS_PROXIES = [
      'https://corsproxy.io/?',
      'https://api.allorigins.win/raw?url=',
      'https://proxy.cors.sh/'
    ];
    let currentProxyIndex = 0;
    
    async function fetchWithProxy(url) {
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
        const proxy = CORS_PROXIES[proxyIndex];
        try {
          const response = await fetch(`${proxy}${encodeURIComponent(url)}`);
          const data = await response.json();
          if (data.message && data.message.includes('Rate limit')) {
            console.log(`Proxy ${proxy} rate limited, trying next...`);
            continue;
          }
          currentProxyIndex = proxyIndex;
          return data;
        } catch (e) { console.log(`Proxy ${proxy} failed:`, e.message); }
      }
      throw new Error('All CORS proxies failed');
    }
    
    const CORS_PROXY = CORS_PROXIES[0];
    const BURN_WALLET = '0x0050AF0000000000000000000000000000000000';
    
    // ========== EMISSIONS CONFIG ==========
    const EMISSIONS_START_BLOCK = 5422063;
    const LOCKUP_BLOCKS = 241920;
    const BURN_LAG_BLOCKS = 25920;
    const FRESH_START_BLOCK = EMISSIONS_START_BLOCK + LOCKUP_BLOCKS;
    const EMISSIONS_CACHE_DURATION = 30 * 60 * 1000;
    // Use local RPC directly when on localhost, use Vercel API proxy on production
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const CUSTOM_RPC_URL = isLocalhost ? 'http://20.81.235.89:9200' : '/api/rpc';
    
    const wallets = [
      { coin: 'RVN', name: 'Ravencoin', address: 'RXtpH2yp6AA6VvPVTuhCrqxYG7vCGEPMB5', geckoId: 'ravencoin' },
      { coin: 'BCH', name: 'Bitcoin Cash', address: 'qqqea0a7ryny69sskvx857apy3r6wt6w35524nm4xw', geckoId: 'bitcoin-cash' },
      { coin: 'LTC', name: 'Litecoin', address: 'ltc1qlg96gqruz4vu5w86z6rpqxt6ugqxrljxzpvcu8', geckoId: 'litecoin' },
      { coin: 'DOGE', name: 'Dogecoin', address: 'D6rnVyuuHB3x8et741kmXzFuZSTVnJQDke', geckoId: 'dogecoin' }
    ];

    const quaiWallets = [
      { exchange: 'MEXC', address: '0x006243e4eE6C2CF6F993036f27f0A88f265Ddb4a' },
      { exchange: 'GATE', address: '0x007e2F1a4709B812F339f22E18032118FBcc8987' }
    ];

    const coinIcons = {
      RVN: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M16 6l-8 5v10l8 5 8-5V11l-8-5zm0 2.5l5.5 3.5v7l-5.5 3.5-5.5-3.5v-7L16 8.5z" fill="#ffffff"/></svg>`,
      BCH: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M21.2 13.3c-.3-2-2.1-2.7-4.5-2.9V8h-1.8v2.3h-1.5V8h-1.8v2.4H9v1.8h1.3c.7 0 .9.4.9.7v7c0 .5-.3.7-.7.7H9l-.3 2h4.5v2.4h1.8v-2.4h1.5v2.4h1.8v-2.5c3-.2 5.1-.9 5.4-3.6.2-2.2-.8-3.2-2.5-3.6zm-5.9-1.2h2c1.3 0 2 .4 2 1.4 0 1-.7 1.4-2 1.4h-2v-2.8zm2.5 8h-2.5v-3.2h2.5c1.5 0 2.2.5 2.2 1.6 0 1.1-.7 1.6-2.2 1.6z" fill="#ffffff"/></svg>`,
      LTC: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M12.5 24h9.8l.8-3h-6.2l1.5-5.5 2.5-1-.5 1.5h2.5l1-3.5-2.5 1 1.5-5.5h-3.5l-2.5 9-2.5 1 .5-2h-2.5l-1.5 5.5 2.5-1-.8 3z" fill="#ffffff"/></svg>`,
      DOGE: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M13 9h4.5c4 0 6.5 2.5 6.5 7s-2.5 7-6.5 7H13V9zm3 2.5v9h1.5c2.5 0 4-1.5 4-4.5s-1.5-4.5-4-4.5H16zm-3 3h6v2h-6v-2z" fill="#ffffff"/></svg>`,
      QUAI: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M16 6C10.5 6 6 10.5 6 16s4.5 10 10 10 10-4.5 10-10S21.5 6 16 6zm0 3c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zm0 2.5c-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5z" fill="#ffffff"/></svg>`
    };

    let balances = {}, prices = {}, quaiBalances = {}, quaiCharts = {}, quaiHistoryData = {}, selectedTimeRange = {};
    let loadedWithdrawals = [], loadedBurnDeposits = [], lastBurnTime = null;
    let withdrawalsLoaded = false, burnDepositsLoaded = false;
    let lastBurnRefreshTime = null;
    let emissionsData = [], emissionsChart = null, circulatingChart = null, alignedChart = null;

    const CACHE_DURATION = 5 * 60 * 1000;

    function getCachedHistory(exchange, days) {
      try {
        const cached = localStorage.getItem(`quai_history_${exchange}_${days}`);
        if (cached) { const { data, timestamp } = JSON.parse(cached); if (Date.now() - timestamp < CACHE_DURATION) return data; }
      } catch (e) {}
      return null;
    }
    function setCachedHistory(exchange, days, data) { try { localStorage.setItem(`quai_history_${exchange}_${days}`, JSON.stringify({ data, timestamp: Date.now() })); } catch (e) {} }
    function getCachedWithdrawals() { try { const cached = localStorage.getItem('withdrawals_cache'); if (cached) { const { data, timestamp } = JSON.parse(cached); if (Date.now() - timestamp < CACHE_DURATION) return data; } } catch (e) {} return null; }
    function setCachedWithdrawals(data) { try { localStorage.setItem('withdrawals_cache', JSON.stringify({ data, timestamp: Date.now() })); } catch (e) {} }
    function getCachedBurnDeposits() { try { const cached = localStorage.getItem('burn_deposits_cache'); if (cached) { const { data, timestamp } = JSON.parse(cached); if (Date.now() - timestamp < CACHE_DURATION) return data; } } catch (e) {} return null; }
    function setCachedBurnDeposits(data) { try { localStorage.setItem('burn_deposits_cache', JSON.stringify({ data, timestamp: Date.now() })); } catch (e) {} }
    function getCachedEmissions() { try { const cached = localStorage.getItem('emissions_cache'); if (cached) { const { data, timestamp } = JSON.parse(cached); if (Date.now() - timestamp < EMISSIONS_CACHE_DURATION) return data; } } catch (e) {} return null; }
    function setCachedEmissions(data) { try { localStorage.setItem('emissions_cache', JSON.stringify({ data, timestamp: Date.now() })); } catch (e) {} }

    function renderWallets() {
      document.getElementById('wallets').innerHTML = wallets.map((wallet, index) => `
        <div class="wallet-card" data-index="0${index + 1}">
          <div class="wallet-inner">
            <div class="wallet-left">
              <div class="coin-icon-wrapper">${coinIcons[wallet.coin]}</div>
              <div class="wallet-info">
                <h3>${wallet.name} <span class="coin-badge">${wallet.coin}</span></h3>
                <p class="wallet-address">${wallet.address}</p>
                <p class="wallet-price" id="price-${wallet.coin}">Loading price...</p>
                <p class="api-source" id="source-${wallet.coin}"></p>
              </div>
            </div>
            <div class="wallet-right" id="balance-${wallet.coin}"><div class="loading-spinner"><div class="spinner"></div><span>LOADING...</span></div></div>
          </div>
        </div>
      `).join('');
    }

    function renderQuaiWallets() {
      document.getElementById('quai-wallets').innerHTML = quaiWallets.map((wallet, index) => {
        selectedTimeRange[wallet.exchange] = 1;
        return `
        <div class="wallet-card" data-index="0${index + 1}">
          <div class="wallet-inner">
            <div class="wallet-left">
              <div class="coin-icon-wrapper">${coinIcons.QUAI}</div>
              <div class="wallet-info">
                <h3>${wallet.exchange} <span class="coin-badge">QUAI</span></h3>
                <p class="wallet-address">${wallet.address}</p>
                <p class="api-source">via Quai RPC</p>
              </div>
            </div>
            <div class="wallet-right" id="quai-balance-${wallet.exchange}"><div class="loading-spinner"><div class="spinner"></div><span>LOADING...</span></div></div>
          </div>
          <div class="chart-container">
            <div class="chart-header">
              <p class="chart-title">Balance History <span id="chart-info-${wallet.exchange}" style="font-size: 14px; color: #aa7777;"></span></p>
              <div class="time-range-buttons">
                <button class="time-btn active" data-exchange="${wallet.exchange}" data-days="1" onclick="changeTimeRange('${wallet.exchange}', 1)">24H</button>
                <button class="time-btn" data-exchange="${wallet.exchange}" data-days="7" onclick="changeTimeRange('${wallet.exchange}', 7)">7D</button>
                <button class="time-btn" data-exchange="${wallet.exchange}" data-days="30" onclick="changeTimeRange('${wallet.exchange}', 30)">30D</button>
                <button class="time-btn" data-exchange="${wallet.exchange}" data-days="90" onclick="changeTimeRange('${wallet.exchange}', 90)">90D</button>
              </div>
            </div>
            <div class="chart-wrapper"><canvas id="chart-${wallet.exchange}"></canvas></div>
            <div class="chart-loading" id="chart-loading-${wallet.exchange}"><div class="spinner" style="margin-right: 8px;"></div>Loading chart data...</div>
          </div>
        </div>
      `}).join('');
    }

    async function changeTimeRange(exchange, days) {
      selectedTimeRange[exchange] = days;
      document.querySelectorAll(`.time-btn[data-exchange="${exchange}"]`).forEach(btn => btn.classList.toggle('active', parseInt(btn.dataset.days) === days));
      const cachedHistory = getCachedHistory(exchange, days);
      if (cachedHistory) { quaiHistoryData[exchange] = cachedHistory; createChart(exchange, cachedHistory, days); return; }
      const wallet = quaiWallets.find(w => w.exchange === exchange);
      if (wallet) {
        const loadingEl = document.getElementById(`chart-loading-${exchange}`), canvas = document.getElementById(`chart-${exchange}`);
        if (loadingEl) { loadingEl.style.display = 'flex'; loadingEl.innerHTML = `<div class="spinner" style="margin-right: 8px;"></div>Loading ${days === 1 ? '24H' : days + 'D'} history...`; }
        if (canvas) canvas.style.display = 'none';
        const history = await fetchQuaiBalanceHistory(wallet.address, days);
        quaiHistoryData[exchange] = history;
        setCachedHistory(exchange, days, history);
        createChart(exchange, history, days);
      }
    }

    async function fetchPrices() {
      try {
        const ids = [...wallets.map(w => w.geckoId), 'quai-network'].join(',');
        const data = await (await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`)).json();
        wallets.forEach(wallet => { if (data[wallet.geckoId]) { prices[wallet.coin] = data[wallet.geckoId].usd; document.getElementById(`price-${wallet.coin}`).textContent = `$${prices[wallet.coin].toLocaleString(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 6 })} / ${wallet.coin}`; }});
        if (data['quai-network']) prices['QUAI'] = data['quai-network'].usd;
      } catch (err) { console.error('Failed to fetch prices:', err); }
    }

    async function fetchRVN(address) { const data = await fetchWithProxy(`https://rvn.cryptoscope.io/api/getaddress/?address=${address}`); if (data?.balance !== undefined) return { balance: parseFloat(data.balance), source: 'CryptoScope' }; throw new Error('RVN API failed'); }
    async function fetchBCH(address) { const data = await fetchWithProxy(`https://bchn.fullstack.cash/v5/electrumx/balance/bitcoincash:${address}`); if (data.balance?.confirmed !== undefined) return { balance: (data.balance.confirmed + (data.balance.unconfirmed || 0)) / 1e8, source: 'FullStack.cash' }; throw new Error('BCH API failed'); }
    async function fetchLTC(address) { try { const response = await fetch(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/balance`); if (response.ok) { const data = await response.json(); return { balance: data.balance / 1e8, source: 'BlockCypher' }; } } catch (e) { console.log('LTC direct fetch failed, trying proxy...'); } const data = await fetchWithProxy(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/balance`); return { balance: data.balance / 1e8, source: 'BlockCypher' }; }
    async function fetchDOGE(address) { try { const response = await fetch(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/balance`); if (response.ok) { const data = await response.json(); return { balance: data.balance / 1e8, source: 'BlockCypher' }; } } catch (e) { console.log('DOGE direct fetch failed, trying proxy...'); } const data = await fetchWithProxy(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/balance`); return { balance: data.balance / 1e8, source: 'BlockCypher' }; }

    async function fetchHistoricalQuaiPrices(startTimestamp, endTimestamp) {
      try {
        const url = `https://api.coingecko.com/api/v3/coins/quai-network/market_chart/range?vs_currency=usd&from=${Math.floor(startTimestamp/1000)}&to=${Math.floor(endTimestamp/1000)}`;
        const response = await fetch(url);
        const data = await response.json();
        if (data.prices && Array.isArray(data.prices)) return data.prices;
      } catch (err) { console.error('Failed to fetch historical QUAI prices:', err); }
      return null;
    }

    function findPriceAtTime(priceHistory, targetTimestamp) {
      if (!priceHistory || priceHistory.length === 0) return null;
      let closest = priceHistory[0], closestDiff = Math.abs(priceHistory[0][0] - targetTimestamp);
      for (const [ts, price] of priceHistory) { const diff = Math.abs(ts - targetTimestamp); if (diff < closestDiff) { closestDiff = diff; closest = [ts, price]; } }
      return closest[1];
    }

    async function fetchBurnWalletBalance() {
      try {
        const response = await fetch('https://rpc.quai.network/cyprus1/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', method: 'quai_getBalance', params: [BURN_WALLET, 'latest'], id: 1 }) });
        const data = await response.json();
        return data.result ? parseInt(data.result, 16) / 1e18 : 0;
      } catch (err) { console.error('Failed to fetch burn wallet balance:', err); return 0; }
    }

    async function fetchBurnDeposits(forceRefresh = false) {
      const container = document.getElementById('burn-deposits');
      if (forceRefresh) container.innerHTML = `<div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Loading burn deposits...</span></div>`;
      if (!forceRefresh) { const cached = getCachedBurnDeposits(); if (cached) { renderBurnDeposits(cached.deposits, cached.totalBalance, container); return; } }
      container.innerHTML = `<div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Loading burn deposits...</span></div>`;
      try {
        const totalBalance = await fetchBurnWalletBalance();
        let deposits = [];
        try {
          const data = await fetchWithProxy(`https://quaiscan.io/api?module=account&action=txlist&address=${BURN_WALLET}&sort=desc&page=1&offset=10`);
          if (data.result && Array.isArray(data.result)) deposits = data.result.filter(tx => tx.to && tx.to.toLowerCase() === BURN_WALLET.toLowerCase()).slice(0, 6).map(tx => ({ amount: parseInt(tx.value) / 1e18, from: tx.from, date: new Date(parseInt(tx.timeStamp) * 1000), txid: tx.hash, blockNumber: tx.blockNumber }));
        } catch (apiErr) { console.log('Blockscout API failed, trying alternative:', apiErr); }
        if (deposits.length === 0) {
          try {
            const data = await fetchWithProxy(`https://quaiscan.io/api/v2/addresses/${BURN_WALLET}/transactions?type=coin_transfer`);
            if (data.items && Array.isArray(data.items)) deposits = data.items.filter(tx => tx.to && tx.to.hash && tx.to.hash.toLowerCase() === BURN_WALLET.toLowerCase()).slice(0, 6).map(tx => ({ amount: parseInt(tx.value) / 1e18, from: tx.from?.hash || 'Unknown', date: new Date(tx.timestamp), txid: tx.hash, blockNumber: tx.block }));
          } catch (v2Err) { console.log('V2 API also failed:', v2Err); }
        }
        if (deposits.length === 0) deposits = await fetchBurnDepositsViaRPC();
        if (deposits.length > 0) {
          const timestamps = deposits.map(d => d.date.getTime());
          const minTime = Math.min(...timestamps) - (24 * 60 * 60 * 1000), maxTime = Math.max(...timestamps) + (24 * 60 * 60 * 1000);
          const priceHistory = await fetchHistoricalQuaiPrices(minTime, maxTime);
          if (priceHistory) deposits = deposits.map(d => { const priceAtTime = findPriceAtTime(priceHistory, d.date.getTime()); return { ...d, priceAtTime, usdValueAtTime: priceAtTime ? d.amount * priceAtTime : null }; });
        }
        setCachedBurnDeposits({ deposits: deposits.map(d => ({ ...d, date: d.date.toISOString() })), totalBalance });
        renderBurnDeposits(deposits, totalBalance, container);
      } catch (err) { console.error('Failed to fetch burn deposits:', err); container.innerHTML = '<div class="no-burns">Failed to load burn deposits.</div>'; burnDepositsLoaded = true; updatePendingBurns(); }
    }

    async function fetchBurnDepositsViaRPC() {
      const deposits = [];
      try {
        const blockResponse = await fetch('https://rpc.quai.network/cyprus1/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', method: 'quai_blockNumber', params: [], id: 1 }) });
        const blockData = await blockResponse.json();
        const currentBlock = parseInt(blockData.result, 16);
        for (let i = 0; i < 100 && deposits.length < 6; i++) {
          const blockNum = currentBlock - i, blockHex = '0x' + blockNum.toString(16);
          try {
            const txResponse = await fetch('https://rpc.quai.network/cyprus1/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', method: 'quai_getBlockByNumber', params: [blockHex, true], id: 1 }) });
            const txData = await txResponse.json();
            if (txData.result && txData.result.transactions) {
              for (const tx of txData.result.transactions) {
                if (tx.to && tx.to.toLowerCase() === BURN_WALLET.toLowerCase()) {
                  const value = parseInt(tx.value, 16) / 1e18;
                  if (value > 0) { deposits.push({ amount: value, from: tx.from, date: new Date(Date.now() - (currentBlock - blockNum) * 5000), txid: tx.hash, blockNumber: blockNum }); if (deposits.length >= 6) break; }
                }
              }
            }
          } catch (blockErr) {}
          if (i % 10 === 0) await new Promise(r => setTimeout(r, 100));
        }
      } catch (err) { console.error('RPC-based burn deposit fetch failed:', err); }
      return deposits;
    }

    function renderBurnDeposits(deposits, totalBalance, container) {
      const quaiPrice = prices['QUAI'] || 0, totalUsd = totalBalance * quaiPrice;
      lastBurnRefreshTime = new Date();
      loadedBurnDeposits = deposits;
      burnDepositsLoaded = true;
      if (deposits && deposits.length > 0) { const sortedBurns = [...deposits].sort((a, b) => (b.date instanceof Date ? b.date : new Date(b.date)) - (a.date instanceof Date ? a.date : new Date(a.date))); lastBurnTime = sortedBurns[0].date instanceof Date ? sortedBurns[0].date : new Date(sortedBurns[0].date); }
      updatePendingBurns();
      let html = `<div class="burn-header"><div class="burn-wallet-info"><div class="burn-wallet-label"><span class="burn-icon">üî•</span>QUAI Burn Address</div><div class="burn-wallet-address"><a href="https://quaiscan.io/address/${BURN_WALLET}" target="_blank">${BURN_WALLET}</a></div></div><div class="burn-total"><div class="burn-total-label">Total Burned</div><div class="burn-total-amount">${totalBalance.toLocaleString(undefined, { maximumFractionDigits: 2 })} QUAI</div>${quaiPrice > 0 ? `<div style="color: #cc9999; font-family: 'VT323', monospace; font-size: 14px;">‚âà $${totalUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })}</div>` : ''}</div></div>`;
      if (!deposits || deposits.length === 0) html += '<div class="no-burns">No recent deposits found.</div>';
      else html += deposits.map(d => { const date = d.date instanceof Date ? d.date : new Date(d.date); const fromShort = d.from ? `${d.from.slice(0, 10)}...${d.from.slice(-6)}` : 'Unknown'; const hasHistoricalPrice = d.usdValueAtTime != null; const usdValue = hasHistoricalPrice ? d.usdValueAtTime : (d.amount * quaiPrice); const priceLabel = hasHistoricalPrice ? `$${usdValue.toLocaleString(undefined, { maximumFractionDigits: 2 })} (at time)` : `‚âà $${usdValue.toLocaleString(undefined, { maximumFractionDigits: 2 })} (now)`; return `<div class="burn-item"><div class="burn-item-left"><span class="burn-badge">üî•</span><div class="burn-item-info"><span class="burn-amount">+${d.amount.toLocaleString(undefined, { maximumFractionDigits: 4 })} QUAI</span>${usdValue > 0 ? `<span style="color: #aa8888; font-family: 'VT323', monospace; font-size: 12px;">${priceLabel}</span>` : ''}<span class="burn-from">From: <a href="https://quaiscan.io/address/${d.from}" target="_blank">${fromShort}</a></span></div></div><div class="burn-item-right"><div class="burn-date">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} ${date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div><div class="burn-txid"><a href="https://quaiscan.io/tx/${d.txid}" target="_blank">${d.txid.slice(0, 12)}...${d.txid.slice(-6)}</a></div></div></div>`; }).join('');
      container.innerHTML = html;
    }

    async function fetchRVNWithdrawals(address) {
      try {
        const withdrawals = [];
        let foundWithdrawals = 0;
        const data = await fetchWithProxy(`https://blockbook.ravencoin.org/api/v2/address/${address}?details=txids&pageSize=400&page=1`);
        if (!data || !data.txids || data.txids.length === 0) return [];
        for (const txid of data.txids) {
          if (foundWithdrawals >= 20) break;
          try {
            const tx = await fetchWithProxy(`https://blockbook.ravencoin.org/api/v2/tx/${txid}`);
            const isInput = tx.vin?.some(vin => vin.addresses?.includes(address));
            if (isInput) { const sentAmount = tx.vout?.filter(vout => !vout.addresses?.includes(address)).reduce((sum, vout) => sum + parseInt(vout.value || 0), 0) || 0; if (sentAmount > 0) { withdrawals.push({ coin: 'RVN', amount: sentAmount / 1e8, date: new Date(tx.blockTime * 1000), txid: tx.txid, explorer: `https://blockbook.ravencoin.org/tx/${tx.txid}` }); foundWithdrawals++; } }
            await new Promise(r => setTimeout(r, 100));
          } catch (e) {}
        }
        return withdrawals;
      } catch (err) { return []; }
    }

    async function fetchBCHWithdrawals(address) {
      try {
        const fullAddress = `bitcoincash:${address}`;
        const data = await fetchWithProxy(`https://bchn.fullstack.cash/v5/electrumx/transactions/${fullAddress}`);
        if (!data || !data.transactions) return [];
        const withdrawals = [];
        for (const tx of data.transactions.slice(0, 6)) {
          try {
            const txResult = await fetchWithProxy(`https://bchn.fullstack.cash/v5/electrumx/tx/data/${tx.tx_hash}`);
            const txData = txResult.details || txResult;
            if (txData && txData.vout) {
              const receivedAmount = txData.vout.filter(vout => { const addrs = vout.scriptPubKey?.addresses || []; return addrs.some(a => a.includes(address)); }).reduce((sum, vout) => sum + (parseFloat(vout.value) || 0), 0);
              const totalOut = txData.vout.reduce((sum, vout) => sum + (parseFloat(vout.value) || 0), 0);
              if (receivedAmount === 0 && totalOut > 0) withdrawals.push({ coin: 'BCH', amount: totalOut, date: txData.blocktime ? new Date(txData.blocktime * 1000) : new Date(), txid: tx.tx_hash, explorer: `https://blockchair.com/bitcoin-cash/transaction/${tx.tx_hash}` });
            }
            await new Promise(r => setTimeout(r, 500));
          } catch (e) {}
        }
        return withdrawals;
      } catch (err) { return []; }
    }

    async function fetchLTCWithdrawals(address) {
      try {
        let data;
        try { const response = await fetch(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/full?limit=20`); if (response.ok) data = await response.json(); else throw new Error(); } catch (e) { data = await fetchWithProxy(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/full?limit=20`); }
        if (!data || !data.txs) return [];
        const withdrawals = [];
        for (const tx of data.txs) { const isInput = tx.inputs?.some(input => input.addresses && input.addresses.includes(address)); if (isInput) { const sentAmount = tx.outputs?.filter(out => !out.addresses?.includes(address)).reduce((sum, out) => sum + (out.value || 0), 0) || 0; if (sentAmount > 0) withdrawals.push({ coin: 'LTC', amount: sentAmount / 1e8, date: new Date(tx.confirmed || tx.received), txid: tx.hash, explorer: `https://blockchair.com/litecoin/transaction/${tx.hash}` }); } }
        return withdrawals;
      } catch (err) { return []; }
    }

    async function fetchDOGEWithdrawals(address) {
      try {
        let data;
        try { const response = await fetch(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/full?limit=20`); if (response.ok) data = await response.json(); else throw new Error(); } catch (e) { data = await fetchWithProxy(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/full?limit=20`); }
        if (!data || !data.txs) return [];
        const withdrawals = [];
        for (const tx of data.txs) { const isInput = tx.inputs?.some(input => input.addresses && input.addresses.includes(address)); if (isInput) { const sentAmount = tx.outputs?.filter(out => !out.addresses?.includes(address)).reduce((sum, out) => sum + (out.value || 0), 0) || 0; if (sentAmount > 0) withdrawals.push({ coin: 'DOGE', amount: sentAmount / 1e8, date: new Date(tx.confirmed || tx.received), txid: tx.hash, explorer: `https://blockchair.com/dogecoin/transaction/${tx.hash}` }); } }
        return withdrawals;
      } catch (err) { return []; }
    }

    async function fetchAllWithdrawals(forceRefresh = false) {
      const container = document.getElementById('withdrawals');
      if (forceRefresh) container.innerHTML = `<div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Loading withdrawals...</span></div>`;
      if (!forceRefresh) { const cached = getCachedWithdrawals(); if (cached) { const isNewFormat = cached.withdrawals !== undefined; const withdrawals = isNewFormat ? cached.withdrawals : cached; const failedApis = isNewFormat ? (cached.failedApis || []) : []; const allApisSucceeded = isNewFormat ? cached.allApisSucceeded : true; if (withdrawals && withdrawals.length > 0 && allApisSucceeded) { renderWithdrawals(withdrawals, container, failedApis); return; } } }
      container.innerHTML = `<div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Loading withdrawals...</span></div>`;
      try {
        const apiResults = { RVN: [], BCH: [], LTC: [], DOGE: [] }, failedApis = [];
        try { apiResults.RVN = await fetchRVNWithdrawals(wallets.find(w => w.coin === 'RVN').address); } catch (e) { failedApis.push('RVN'); }
        try { apiResults.BCH = await fetchBCHWithdrawals(wallets.find(w => w.coin === 'BCH').address); } catch (e) { failedApis.push('BCH'); }
        try { apiResults.LTC = await fetchLTCWithdrawals(wallets.find(w => w.coin === 'LTC').address); } catch (e) { failedApis.push('LTC'); }
        try { apiResults.DOGE = await fetchDOGEWithdrawals(wallets.find(w => w.coin === 'DOGE').address); } catch (e) { failedApis.push('DOGE'); }
        let allWithdrawals = [...apiResults.RVN, ...apiResults.BCH, ...apiResults.LTC, ...apiResults.DOGE].filter(w => w.date && !isNaN(w.date.getTime())).sort((a, b) => b.date - a.date).slice(0, 20);
        const uniqueFailedApis = [...new Set(failedApis)];
        const allApisSucceeded = uniqueFailedApis.length === 0;
        if (allApisSucceeded) setCachedWithdrawals({ withdrawals: allWithdrawals.map(w => ({ ...w, date: w.date.toISOString() })), allApisSucceeded, failedApis: uniqueFailedApis });
        renderWithdrawals(allWithdrawals, container, uniqueFailedApis);
      } catch (err) { container.innerHTML = '<div class="no-withdrawals">Failed to load withdrawals</div>'; withdrawalsLoaded = true; updatePendingBurns(); }
    }

    function renderWithdrawals(withdrawals, container, failedApis = []) {
      loadedWithdrawals = withdrawals;
      withdrawalsLoaded = true;
      updatePendingBurns();
      if (withdrawals.length === 0) { container.innerHTML = '<div class="no-withdrawals">No recent withdrawals found</div>'; return; }
      let warningHtml = '';
      if (failedApis.length > 0) warningHtml = `<div style="background: #3d2020; border: 1px solid #6b3333; padding: 10px 16px; margin-bottom: 8px; color: #ffaaaa; font-family: 'VT323', monospace; font-size: 14px;">‚ö†Ô∏è Warning: ${failedApis.join(', ')} withdrawal data may be incomplete.</div>`;
      container.innerHTML = warningHtml + withdrawals.map(w => { const date = w.date instanceof Date ? w.date : new Date(w.date); const currentPrice = prices[w.coin] || 0; const usdValue = w.amount * currentPrice; const priceLabel = currentPrice > 0 ? `‚âà $${usdValue.toLocaleString(undefined, { maximumFractionDigits: 2 })}` : ''; return `<div class="withdrawal-item"><div class="withdrawal-left"><span class="withdrawal-coin-badge">${w.coin}</span><div class="withdrawal-info"><span class="withdrawal-amount">-${w.amount.toLocaleString(undefined, { maximumFractionDigits: 8 })} ${w.coin}</span>${priceLabel ? `<span class="withdrawal-to">${priceLabel}</span>` : '<span class="withdrawal-to">Sent from wallet</span>'}</div></div><div class="withdrawal-right"><div class="withdrawal-date">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} ${date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div><div class="withdrawal-txid"><a href="${w.explorer}" target="_blank">${w.txid.slice(0, 12)}...${w.txid.slice(-6)}</a></div></div></div>`; }).join('');
    }

    function updatePendingBurns() {
      const container = document.getElementById('pending-burns');
      if (!withdrawalsLoaded || !burnDepositsLoaded) return;
      if (loadedWithdrawals.length === 0 && loadedBurnDeposits.length === 0) { container.innerHTML = `<div class="no-pending"><div class="all-burned-icon">üì≠</div>No withdrawal or burn data available</div>`; return; }
      const withdrawalsWithBalance = loadedWithdrawals.map(w => { const date = w.date instanceof Date ? w.date : new Date(w.date); const currentPrice = prices[w.coin] || 0; const usdValue = w.amount * currentPrice; return { ...w, date, usdValue, remainingUsd: usdValue, originalUsd: usdValue }; }).sort((a, b) => a.date - b.date);
      const quaiPrice = prices['QUAI'] || 0;
      const burnsWithUsd = loadedBurnDeposits.map(b => { const date = b.date instanceof Date ? b.date : new Date(b.date); const usdValue = b.usdValueAtTime != null ? b.usdValueAtTime : (b.amount * quaiPrice); return { ...b, date, usdValue, usedHistoricalPrice: b.usdValueAtTime != null }; }).sort((a, b) => b.date - a.date).slice(0, 4).sort((a, b) => a.date - b.date);
      for (const burn of burnsWithUsd) { let burnRemaining = burn.usdValue; for (const withdrawal of withdrawalsWithBalance) { if (burnRemaining <= 0) break; if (withdrawal.remainingUsd <= 0) continue; if (withdrawal.date >= burn.date) continue; const deduction = Math.min(burnRemaining, withdrawal.remainingUsd); withdrawal.remainingUsd -= deduction; burnRemaining -= deduction; } }
      const pendingWithdrawals = withdrawalsWithBalance.filter(w => w.remainingUsd > 0.01).sort((a, b) => b.date - a.date);
      renderPendingBurnsUI(pendingWithdrawals, container);
    }

    function renderPendingBurnsUI(pendingWithdrawals, container) {
      const totalPendingUsd = pendingWithdrawals.reduce((sum, w) => sum + w.remainingUsd, 0);
      if (pendingWithdrawals.length === 0 || totalPendingUsd < 0.01) { container.innerHTML = `<div class="no-pending"><div class="all-burned-icon">‚úÖ</div>All tracked withdrawals have been burned!</div>`; return; }
      let html = `<div class="pending-header"><div class="pending-info"><div class="pending-label"><span class="pending-icon">‚è≥</span>Withdrawals Awaiting Burn</div><div class="pending-subtitle">${pendingWithdrawals.length} withdrawal${pendingWithdrawals.length !== 1 ? 's' : ''} not fully burned yet</div></div><div class="pending-total"><div class="pending-total-label">Total Pending</div><div class="pending-total-amount">$${totalPendingUsd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div></div></div>`;
      html += pendingWithdrawals.map(w => { const isPartial = w.remainingUsd < w.originalUsd - 0.01; const burnedPercent = ((w.originalUsd - w.remainingUsd) / w.originalUsd * 100).toFixed(0); return `<div class="pending-item"><div class="pending-item-left"><span class="pending-badge">${w.coin}</span><div class="pending-item-info"><span class="pending-amount">${w.amount.toLocaleString(undefined, { maximumFractionDigits: 8 })} ${w.coin}</span><span class="pending-coin">${isPartial ? `$${w.remainingUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })} pending of $${w.originalUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })} (${burnedPercent}% burned)` : `$${w.originalUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })}`}</span></div></div><div class="pending-item-right"><div class="pending-date">${w.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} ${w.date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div><div class="pending-status">${isPartial ? 'üî• Partially burned' : '‚è≥ Awaiting burn'}</div></div></div>`; }).join('');
      container.innerHTML = html;
    }

    async function fetchQuaiBalance(address) {
      const response = await fetch('https://rpc.quai.network/cyprus1/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', method: 'quai_getBalance', params: [address, 'latest'], id: 1 }) });
      const data = await response.json();
      if (data.result) return parseInt(data.result, 16) / 1e18;
      throw new Error('QUAI RPC failed');
    }

    async function fetchQuaiBlockNumber() {
      const response = await fetch('https://rpc.quai.network/cyprus1/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', method: 'quai_blockNumber', params: [], id: 1 }) });
      const data = await response.json();
      if (data.result) return parseInt(data.result, 16);
      throw new Error('Failed to get block number');
    }

    async function fetchQuaiBalanceAtBlock(address, blockHex) {
      const response = await fetch('https://rpc.quai.network/cyprus1/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', method: 'quai_getBalance', params: [address, blockHex], id: 1 }) });
      const data = await response.json();
      return data.result ? parseInt(data.result, 16) / 1e18 : null;
    }

    async function fetchQuaiBalanceHistory(address, days) {
      const BLOCKS_PER_DAY = 17280, targetDataPoints = 100;
      try {
        const currentBlock = await fetchQuaiBlockNumber();
        const totalBlocks = days * BLOCKS_PER_DAY, startBlock = Math.max(1, currentBlock - totalBlocks), stepSize = Math.max(90, Math.floor(totalBlocks / targetDataPoints));
        const historyData = [];
        for (let block = startBlock; block <= currentBlock; block += stepSize) {
          const blockHex = '0x' + block.toString(16), balance = await fetchQuaiBalanceAtBlock(address, blockHex);
          if (balance !== null) { const blocksFromNow = currentBlock - block, msFromNow = (blocksFromNow / BLOCKS_PER_DAY) * 24 * 60 * 60 * 1000; historyData.push({ block, date: new Date(Date.now() - msFromNow).toISOString(), balance }); }
          await new Promise(r => setTimeout(r, 50));
        }
        return historyData;
      } catch (err) { console.error('Failed to fetch QUAI history:', err); return null; }
    }

    function createChart(exchange, historyData, days = 1) {
      const canvas = document.getElementById(`chart-${exchange}`), loadingEl = document.getElementById(`chart-loading-${exchange}`), infoEl = document.getElementById(`chart-info-${exchange}`);
      if (!historyData || !Array.isArray(historyData) || historyData.length === 0) { loadingEl.innerHTML = 'No historical data available'; loadingEl.style.display = 'flex'; canvas.style.display = 'none'; if (infoEl) infoEl.textContent = ''; return; }
      const sortedData = [...historyData].sort((a, b) => new Date(a.date) - new Date(b.date));
      if (sortedData.length === 0) { loadingEl.innerHTML = `No data available`; loadingEl.style.display = 'flex'; canvas.style.display = 'none'; if (infoEl) infoEl.textContent = ''; return; }
      if (infoEl) { const firstDate = new Date(sortedData[0].date), lastDate = new Date(sortedData[sortedData.length - 1].date); let dateFormat = days <= 1 ? { hour: '2-digit', minute: '2-digit' } : { month: 'short', day: 'numeric' }; infoEl.textContent = `(${sortedData.length} points: ${firstDate.toLocaleString('en-US', dateFormat)} - ${lastDate.toLocaleString('en-US', dateFormat)})`; }
      loadingEl.style.display = 'none'; canvas.style.display = 'block';
      const labels = sortedData.map(d => { const date = new Date(d.date); if (days <= 1) return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }); else if (days <= 7) return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit' }); return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }); });
      const values = sortedData.map(d => d.balance);
      if (quaiCharts[exchange]) quaiCharts[exchange].destroy();
      const pointRadius = sortedData.length <= 30 ? 3 : sortedData.length <= 60 ? 2 : sortedData.length <= 100 ? 1 : 0;
      quaiCharts[exchange] = new Chart(canvas, { type: 'line', data: { labels, datasets: [{ label: 'Balance (QUAI)', data: values, borderColor: '#ff6666', backgroundColor: 'rgba(255, 102, 102, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius, pointHoverRadius: 5, pointBackgroundColor: '#ff6666', pointHoverBackgroundColor: '#ff6666' }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { backgroundColor: '#2a1010', borderColor: '#ff6666', borderWidth: 1, titleColor: '#ffffff', bodyColor: '#ffaaaa', callbacks: { label: ctx => `${ctx.parsed.y.toLocaleString(undefined, { maximumFractionDigits: 2 })} QUAI` } } }, scales: { x: { grid: { color: 'rgba(255, 102, 102, 0.1)' }, ticks: { color: '#aa8888', font: { family: 'VT323', size: 12 }, maxTicksLimit: 8 } }, y: { grid: { color: 'rgba(255, 102, 102, 0.1)' }, ticks: { color: '#aa8888', font: { family: 'VT323', size: 12 }, callback: v => v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(1)+'K' : v.toFixed(0) } } }, interaction: { intersect: false, mode: 'index' } } });
    }

    async function fetchBalance(wallet) {
      const el = document.getElementById(`balance-${wallet.coin}`), sourceEl = document.getElementById(`source-${wallet.coin}`);
      try {
        const result = await ({ RVN: fetchRVN, BCH: fetchBCH, LTC: fetchLTC, DOGE: fetchDOGE }[wallet.coin](wallet.address));
        balances[wallet.coin] = result.balance;
        const usdValue = result.balance * (prices[wallet.coin] || 0);
        el.innerHTML = `<p class="wallet-balance">${result.balance.toLocaleString(undefined, { maximumFractionDigits: 8 })}<span class="wallet-balance-coin">${wallet.coin}</span></p><p class="wallet-usd">$${usdValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>`;
        sourceEl.textContent = `via ${result.source}`;
      } catch (err) { console.error(`Failed to fetch ${wallet.coin}:`, err); el.innerHTML = `<p class="wallet-error">FAILED TO LOAD</p>`; sourceEl.textContent = 'API error'; balances[wallet.coin] = 0; }
    }

    async function fetchQuaiWalletData(wallet, days = 1, forceRefresh = false) {
      const el = document.getElementById(`quai-balance-${wallet.exchange}`);
      try {
        const balance = await fetchQuaiBalance(wallet.address);
        quaiBalances[wallet.exchange] = balance;
        const usdValue = balance * (prices['QUAI'] || 0);
        el.innerHTML = `<p class="wallet-balance">${balance.toLocaleString(undefined, { maximumFractionDigits: 4 })}<span class="wallet-balance-coin">QUAI</span></p><p class="wallet-usd">$${usdValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>`;
        let history = null;
        if (!forceRefresh) history = getCachedHistory(wallet.exchange, days);
        if (history) { quaiHistoryData[wallet.exchange] = history; createChart(wallet.exchange, history, days); }
        else { const loadingEl = document.getElementById(`chart-loading-${wallet.exchange}`); if (loadingEl) { loadingEl.style.display = 'flex'; loadingEl.innerHTML = `<div class="spinner" style="margin-right: 8px;"></div>Loading history...`; } history = await fetchQuaiBalanceHistory(wallet.address, days); quaiHistoryData[wallet.exchange] = history; setCachedHistory(wallet.exchange, days, history); createChart(wallet.exchange, history, days); }
      } catch (err) { console.error(`Failed to fetch ${wallet.exchange} QUAI:`, err); el.innerHTML = `<p class="wallet-error">FAILED TO LOAD</p>`; quaiBalances[wallet.exchange] = 0; document.getElementById(`chart-loading-${wallet.exchange}`).innerHTML = 'Failed to load chart'; }
    }

    function updateTotal() {
      let total = 0;
      wallets.forEach(w => total += (balances[w.coin] || 0) * (prices[w.coin] || 0));
      document.getElementById('total-usd').textContent = `$${total.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
      document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
    }

    // ========== EMISSIONS FUNCTIONS ==========
    async function fetchEmissionsRpc(method, params) {
      try {
        const response = await fetch(CUSTOM_RPC_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params }) });
        if (response.ok) return await response.json();
      } catch (e) { console.log('Emissions RPC failed:', e.message); }
      return null;
    }

    async function fetchEmissionsBlockNumber() { const d = await fetchEmissionsRpc('quai_blockNumber', []); return d?.result ? parseInt(d.result, 16) : null; }
    async function fetchMiningInfoAtBlock(blockNumber) { const d = await fetchEmissionsRpc('quai_getMiningInfo', ['0x' + blockNumber.toString(16), true]); return d?.result || null; }
    async function fetchBurnBalanceAtBlock(blockNumber) { const d = await fetchEmissionsRpc('quai_getBalance', [BURN_WALLET, '0x' + blockNumber.toString(16)]); return d?.result ? parseInt(d.result, 16) / 1e18 : null; }
    function calculateDailyEmissions(info) { const sha = parseFloat(info.avgShaShareTime) || 1, scrypt = parseFloat(info.avgScryptShareTime) || 1, kawpow = parseFloat(info.avgKawpowShareTime) || 1, reward = Number(BigInt(info.workshareReward || '0')) / 1e18; return (86400/sha + 86400/scrypt + 86400/kawpow) * reward; }
    function interpolateValue(data, targetBlock, key) { if (data.length === 0) return 0; if (targetBlock <= data[0].block) return data[0][key]; if (targetBlock >= data[data.length - 1].block) return data[data.length - 1][key]; for (let i = 0; i < data.length - 1; i++) { if (targetBlock >= data[i].block && targetBlock <= data[i + 1].block) { const ratio = (targetBlock - data[i].block) / (data[i + 1].block - data[i].block); return data[i][key] + (data[i + 1][key] - data[i][key]) * ratio; } } return data[data.length - 1][key]; }

    async function fetchEmissionsVsBurnsData(forceRefresh = false) {
      const loadingEl = document.getElementById('emissions-loading'), loadingText = document.getElementById('emissions-loading-text'), progressBar = document.getElementById('emissions-progress-bar'), canvas = document.getElementById('emissions-chart');
      
      if (!forceRefresh) { const cached = getCachedEmissions(); if (cached && cached.length > 0) { emissionsData = cached; renderEmissionsChart(); renderCirculatingChart(); renderAlignedChart(); return; } }
      loadingText.textContent = 'Fetching current block...';
      const currentBlock = await fetchEmissionsBlockNumber();
      if (!currentBlock || currentBlock < EMISSIONS_START_BLOCK) { loadingText.textContent = 'Could not connect to RPC'; return; }
      
      // Test if getMiningInfo is available
      const testMiningInfo = await fetchMiningInfoAtBlock(currentBlock);
      if (!testMiningInfo) { loadingText.textContent = 'getMiningInfo not available on this RPC'; return; }
      
      document.getElementById('emissions-block-range').textContent = `Block range: ${EMISSIONS_START_BLOCK.toLocaleString()} ‚Üí ${currentBlock.toLocaleString()}`;
      const dataPoints = 50, blockRange = currentBlock - EMISSIONS_START_BLOCK, blockStep = Math.floor(blockRange / dataPoints);
      emissionsData = [];
      let cumulativeEmissions = 0;
      
      for (let i = 0; i <= dataPoints; i++) {
        const block = EMISSIONS_START_BLOCK + (i * blockStep);
        const progress = Math.round((i / dataPoints) * 100);
        loadingText.textContent = `Fetching block ${block.toLocaleString()}... (${progress}%)`;
        progressBar.style.width = `${progress}%`;
        
        const [miningInfo, burnBalance] = await Promise.all([fetchMiningInfoAtBlock(block), fetchBurnBalanceAtBlock(block)]);
        if (miningInfo) {
          const dailyEmissions = calculateDailyEmissions(miningInfo);
          if (i > 0) { const blocksDelta = block - emissionsData[emissionsData.length - 1].block; cumulativeEmissions += dailyEmissions * (blocksDelta / 17280); }
          emissionsData.push({ block, cumulativeEmissions, cumulativeBurns: burnBalance || 0 });
        }
        await new Promise(r => setTimeout(r, 100));
      }
      
      setCachedEmissions(emissionsData);
      renderEmissionsChart();
      renderCirculatingChart();
      renderAlignedChart();
    }

    function renderEmissionsChart() {
      const canvas = document.getElementById('emissions-chart'), loadingEl = document.getElementById('emissions-loading');
      if (!emissionsData || emissionsData.length === 0) { loadingEl.innerHTML = '<span>No emissions data available</span>'; return; }
      loadingEl.style.display = 'none'; canvas.style.display = 'block';
      
      // Get the latest block and calculate the burn baseline at FRESH_START_BLOCK
      const latestBlock = emissionsData[emissionsData.length - 1].block;
      const burnBaseline = interpolateValue(emissionsData, FRESH_START_BLOCK, 'cumulativeBurns');
      
      // Filter data to start from FRESH_START_BLOCK and apply 36hr lag to burns
      const alignedData = emissionsData.filter(d => d.block >= FRESH_START_BLOCK && d.block <= latestBlock - BURN_LAG_BLOCKS).map(d => {
        const alignedBurnBlock = d.block + BURN_LAG_BLOCKS;
        const alignedBurns = interpolateValue(emissionsData, alignedBurnBlock, 'cumulativeBurns') - burnBaseline;
        // Also adjust emissions to be relative to FRESH_START_BLOCK
        const baselineEmissions = interpolateValue(emissionsData, FRESH_START_BLOCK, 'cumulativeEmissions');
        return { 
          block: d.block, 
          cumulativeEmissions: d.cumulativeEmissions - baselineEmissions, 
          alignedBurns 
        };
      });
      
      if (alignedData.length === 0) { loadingEl.innerHTML = '<span>Not enough data for aligned chart</span>'; return; }
      
      const latest = alignedData[alignedData.length - 1];
      document.getElementById('total-emissions').textContent = latest.cumulativeEmissions.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      document.getElementById('total-burns-stat').textContent = latest.alignedBurns.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      document.getElementById('net-supply').textContent = (latest.cumulativeEmissions - latest.alignedBurns).toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      
      const labels = alignedData.map(d => d.block.toLocaleString());
      const emissionsValues = alignedData.map(d => d.cumulativeEmissions);
      const burnsValues = alignedData.map(d => d.alignedBurns);
      
      if (emissionsChart) emissionsChart.destroy();
      emissionsChart = new Chart(canvas, { type: 'line', data: { labels, datasets: [{ label: 'Cumulative Emissions', data: emissionsValues, borderColor: '#66ccff', backgroundColor: 'rgba(102, 204, 255, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }, { label: 'Burns (aligned -36hrs)', data: burnsValues, borderColor: '#ff9966', backgroundColor: 'rgba(255, 153, 102, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { backgroundColor: '#0a1520', borderColor: '#205a6b', borderWidth: 1, titleColor: '#ffffff', bodyColor: '#88ccee', callbacks: { title: ctx => `Block ${ctx[0].label}`, label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString(undefined, { maximumFractionDigits: 0 })} QUAI` } } }, scales: { x: { grid: { color: 'rgba(102, 204, 255, 0.1)' }, ticks: { color: '#88aabb', font: { family: 'VT323', size: 12 }, maxTicksLimit: 6 } }, y: { grid: { color: 'rgba(102, 204, 255, 0.1)' }, ticks: { color: '#88aabb', font: { family: 'VT323', size: 12 }, callback: v => v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(0)+'K' : v.toFixed(0) } } }, interaction: { intersect: false, mode: 'index' } } });
    }

    function renderCirculatingChart() {
      const canvas = document.getElementById('circulating-chart'), loadingEl = document.getElementById('circulating-loading');
      if (!emissionsData || emissionsData.length === 0) return;
      loadingEl.style.display = 'none'; canvas.style.display = 'block';
      
      const latestBlock = emissionsData[emissionsData.length - 1].block;
      const burnBaseline = interpolateValue(emissionsData, FRESH_START_BLOCK, 'cumulativeBurns');
      
      // Apply both 2-week lockup to emissions AND 36hr lag to burns
      const circData = emissionsData.filter(d => d.block >= FRESH_START_BLOCK && d.block <= latestBlock - BURN_LAG_BLOCKS).map(d => {
        const unlockBlock = d.block - LOCKUP_BLOCKS;
        const unlockedEmissions = unlockBlock >= EMISSIONS_START_BLOCK ? interpolateValue(emissionsData, unlockBlock, 'cumulativeEmissions') : 0;
        // Apply 36hr lag to burns
        const alignedBurnBlock = d.block + BURN_LAG_BLOCKS;
        const alignedBurns = interpolateValue(emissionsData, alignedBurnBlock, 'cumulativeBurns') - burnBaseline;
        return { block: d.block, unlockedEmissions, alignedBurns };
      });
      
      if (circData.length === 0) return;
      
      const latest = circData[circData.length - 1];
      document.getElementById('unlocked-emissions').textContent = latest.unlockedEmissions.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      document.getElementById('circ-total-burns').textContent = latest.alignedBurns.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      document.getElementById('net-circulating').textContent = (latest.unlockedEmissions - latest.alignedBurns).toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      
      if (circulatingChart) circulatingChart.destroy();
      circulatingChart = new Chart(canvas, { type: 'line', data: { labels: circData.map(d => d.block.toLocaleString()), datasets: [{ label: 'Unlocked Emissions', data: circData.map(d => d.unlockedEmissions), borderColor: '#99ff66', backgroundColor: 'rgba(153, 255, 102, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }, { label: 'Burns (aligned -36hrs)', data: circData.map(d => d.alignedBurns), borderColor: '#ff9966', backgroundColor: 'rgba(255, 153, 102, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { backgroundColor: '#101a08', borderColor: '#4a6b20', borderWidth: 1, titleColor: '#ffffff', bodyColor: '#99ff66' } }, scales: { x: { grid: { color: 'rgba(153, 255, 102, 0.1)' }, ticks: { color: '#88bb88', font: { family: 'VT323', size: 12 }, maxTicksLimit: 6 } }, y: { grid: { color: 'rgba(153, 255, 102, 0.1)' }, ticks: { color: '#88bb88', font: { family: 'VT323', size: 12 }, callback: v => v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(0)+'K' : v.toFixed(0) } } }, interaction: { intersect: false, mode: 'index' } } });
    }

    function renderAlignedChart() {
      const canvas = document.getElementById('aligned-chart'), loadingEl = document.getElementById('aligned-loading');
      if (!emissionsData || emissionsData.length === 0) return;
      loadingEl.style.display = 'none'; canvas.style.display = 'block';
      const latestBlock = emissionsData[emissionsData.length - 1].block;
      const burnBaseline = interpolateValue(emissionsData, FRESH_START_BLOCK, 'cumulativeBurns');
      const alignedData = emissionsData.filter(d => d.block >= FRESH_START_BLOCK && d.block <= latestBlock - BURN_LAG_BLOCKS).map(d => {
        const unlockBlock = d.block - LOCKUP_BLOCKS, unlockedEmissions = unlockBlock >= EMISSIONS_START_BLOCK ? interpolateValue(emissionsData, unlockBlock, 'cumulativeEmissions') : 0;
        const alignedBurnBlock = d.block + BURN_LAG_BLOCKS, alignedBurns = interpolateValue(emissionsData, alignedBurnBlock, 'cumulativeBurns') - burnBaseline;
        return { block: d.block, unlockedEmissions, alignedBurns, netAligned: unlockedEmissions - alignedBurns };
      });
      if (alignedData.length === 0) return;
      const latest = alignedData[alignedData.length - 1];
      document.getElementById('aligned-unlocked').textContent = latest.unlockedEmissions.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      document.getElementById('aligned-burns').textContent = latest.alignedBurns.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      document.getElementById('aligned-net').textContent = latest.netAligned.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' QUAI';
      if (alignedChart) alignedChart.destroy();
      alignedChart = new Chart(canvas, { type: 'line', data: { labels: alignedData.map(d => d.block.toLocaleString()), datasets: [{ label: 'Unlocked Emissions', data: alignedData.map(d => d.unlockedEmissions), borderColor: '#99ff66', backgroundColor: 'rgba(153, 255, 102, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }, { label: 'Burns (aligned)', data: alignedData.map(d => d.alignedBurns), borderColor: '#ff9966', backgroundColor: 'rgba(255, 153, 102, 0.1)', borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }, { label: 'Net (aligned)', data: alignedData.map(d => d.netAligned), borderColor: '#cc99ff', backgroundColor: 'rgba(204, 153, 255, 0.1)', borderWidth: 2, fill: false, tension: 0.4, pointRadius: 0, borderDash: [5, 5] }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { backgroundColor: '#100818', borderColor: '#4a206b', borderWidth: 1, titleColor: '#ffffff', bodyColor: '#cc99ff' } }, scales: { x: { grid: { color: 'rgba(204, 153, 255, 0.1)' }, ticks: { color: '#aa88bb', font: { family: 'VT323', size: 12 }, maxTicksLimit: 6 } }, y: { grid: { color: 'rgba(204, 153, 255, 0.1)' }, ticks: { color: '#aa88bb', font: { family: 'VT323', size: 12 }, callback: v => v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(0)+'K' : v.toFixed(0) } } }, interaction: { intersect: false, mode: 'index' } } });
    }

    async function fetchAllBalances(forceRefresh = false) {
      const btn = document.getElementById('refresh-btn'), icon = document.getElementById('refresh-icon'), text = document.getElementById('refresh-text');
      btn.disabled = true; icon.classList.add('spinning'); text.textContent = 'Loading...';
      withdrawalsLoaded = false; burnDepositsLoaded = false;
      document.getElementById('pending-burns').innerHTML = `<div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Calculating pending burns...</span></div>`;
      await fetchPrices();
      for (const wallet of wallets) { await fetchBalance(wallet); await new Promise(r => setTimeout(r, 400)); }
      updateTotal();
      fetchAllWithdrawals(forceRefresh);
      fetchBurnDeposits(forceRefresh);
      fetchEmissionsVsBurnsData(forceRefresh);
      for (const wallet of quaiWallets) { await fetchQuaiWalletData(wallet, selectedTimeRange[wallet.exchange] || 1); await new Promise(r => setTimeout(r, 400)); }
      updateTotal();
      btn.disabled = false; icon.classList.remove('spinning'); text.textContent = 'Refresh';
    }

    function manualRefresh() { resetRefreshCountdown(); fetchAllBalances(true); }

    const AUTO_REFRESH_INTERVAL = 5 * 60 * 1000;
    let nextRefreshTime = Date.now() + AUTO_REFRESH_INTERVAL;
    function resetRefreshCountdown() { nextRefreshTime = Date.now() + AUTO_REFRESH_INTERVAL; }
    function updateRefreshCountdown() { const remaining = Math.max(0, nextRefreshTime - Date.now()), minutes = Math.floor(remaining / 60000), seconds = Math.floor((remaining % 60000) / 1000); const el = document.getElementById('next-refresh'); if (el) el.textContent = `Auto-refresh in ${minutes}:${seconds.toString().padStart(2, '0')}`; }
    setInterval(updateRefreshCountdown, 1000);
    setInterval(async () => { console.log('Auto-refreshing data...'); resetRefreshCountdown(); withdrawalsLoaded = false; burnDepositsLoaded = false; document.getElementById('pending-burns').innerHTML = `<div class="loading-spinner" style="justify-content: center; padding: 20px;"><div class="spinner"></div><span>Auto-refreshing...</span></div>`; await Promise.all([fetchBurnDeposits(true), fetchAllWithdrawals(true)]); }, AUTO_REFRESH_INTERVAL);

    renderWallets();
    renderQuaiWallets();
    fetchAllBalances();
  </script>
</body>
</html>
