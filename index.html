<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Wallet Tracker</title>
  <link href="https://fonts.googleapis.com/css2?family=VT323&family=Playfair+Display:wght@400;700&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      min-height: 100vh; 
      background: #1a0a0a; 
      color: #fff;
      font-family: 'Courier Prime', monospace;
      position: relative;
    }

    .bg-pattern {
      position: fixed;
      inset: 0;
      opacity: 0.02;
      background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0L60 30L30 60L0 30L30 0z' fill='%23ff0000' fill-opacity='1'/%3E%3C/svg%3E");
      background-size: 30px 30px;
    }

    .container { 
      position: relative; 
      z-index: 10; 
      max-width: 900px; 
      margin: 0 auto; 
      padding: 48px 24px; 
    }

    header { 
      text-align: center; 
      margin-bottom: 48px;
      border-bottom: 2px solid #8b0000;
      padding-bottom: 32px;
    }

    .ornament { color: #ff6666; font-size: 24px; letter-spacing: 8px; margin-bottom: 16px; }

    h1 { 
      font-family: 'Playfair Display', serif;
      font-size: 3rem; 
      font-weight: 700;
      color: #ff4444;
      text-shadow: 2px 2px 0px #4a0000, 0 0 30px rgba(255, 68, 68, 0.4);
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .subtitle { color: #f5f5f5; font-size: 1rem; letter-spacing: 3px; text-transform: uppercase; }

    .total-card { 
      position: relative; 
      padding: 32px; 
      margin-bottom: 40px;
      background: linear-gradient(135deg, #2a1010 0%, #1a0808 100%);
      border: 2px solid #6b2222;
      box-shadow: inset 0 0 30px rgba(139, 0, 0, 0.2), 0 0 20px rgba(139, 0, 0, 0.1);
    }

    .total-card::before {
      content: '';
      position: absolute;
      top: 8px; left: 8px; right: 8px; bottom: 8px;
      border: 1px solid #4a1a1a;
      pointer-events: none;
    }

    .corner { position: absolute; width: 20px; height: 20px; border-color: #ff6666; border-style: solid; }
    .corner-tl { top: -2px; left: -2px; border-width: 3px 0 0 3px; }
    .corner-tr { top: -2px; right: -2px; border-width: 3px 3px 0 0; }
    .corner-bl { bottom: -2px; left: -2px; border-width: 0 0 3px 3px; }
    .corner-br { bottom: -2px; right: -2px; border-width: 0 3px 3px 0; }

    .total-label { color: #ffffff; font-size: 14px; text-transform: uppercase; letter-spacing: 4px; margin-bottom: 8px; }
    .total-value { display: flex; align-items: baseline; gap: 8px; justify-content: center; }
    .total-amount { 
      font-family: 'VT323', monospace;
      font-size: 4rem; 
      color: #ff4444;
      text-shadow: 0 0 20px rgba(255, 68, 68, 0.5), 0 0 40px rgba(255, 68, 68, 0.3);
      letter-spacing: 2px;
    }
    .total-currency { font-size: 1.5rem; color: #ffaaaa; }
    .last-updated { color: #f0f0f0; font-size: 14px; margin-top: 16px; text-align: center; font-style: italic; }

    .refresh-container { display: flex; justify-content: center; margin-bottom: 40px; }
    .refresh-btn { 
      display: flex; align-items: center; gap: 12px; padding: 14px 32px;
      background: linear-gradient(180deg, #3d1515 0%, #2a0a0a 100%);
      border: 2px solid #ff6666; color: #ffffff;
      font-family: 'Courier Prime', monospace; font-size: 14px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 2px; cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 0 #4a0000, 0 0 20px rgba(139, 0, 0, 0.2);
    }
    .refresh-btn:hover { background: linear-gradient(180deg, #4a1a1a 0%, #3d1010 100%); box-shadow: 0 4px 0 #4a0000, 0 0 30px rgba(196, 30, 58, 0.4); }
    .refresh-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #4a0000; }
    .refresh-btn:disabled { cursor: not-allowed; opacity: 0.5; }
    .refresh-icon { width: 18px; height: 18px; }

    @keyframes spin { to { transform: rotate(360deg); } }
    .spinning { animation: spin 1s linear infinite; }

    .section-title {
      font-family: 'Playfair Display', serif; font-size: 1.5rem; color: #ff6666;
      text-align: center; margin: 40px 0 24px; padding-bottom: 12px;
      border-bottom: 1px solid #4a1515; text-transform: uppercase; letter-spacing: 3px;
    }

    .wallets { display: flex; flex-direction: column; gap: 16px; }

    .wallet-card { 
      position: relative; padding: 20px 24px;
      background: linear-gradient(135deg, #251010 0%, #1a0808 100%);
      border: 1px solid #5a2020; transition: all 0.3s;
    }
    .wallet-card:hover { border-color: #aa3333; box-shadow: 0 0 20px rgba(170, 51, 51, 0.3), inset 0 0 30px rgba(139, 0, 0, 0.1); }
    .wallet-card::before {
      content: attr(data-index); position: absolute; top: -1px; left: 20px;
      background: #1a0a0a; padding: 0 10px;
      font-family: 'VT323', monospace; font-size: 18px; color: #ff9999;
    }

    .wallet-inner { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px; }
    .wallet-left { display: flex; align-items: center; gap: 16px; }
    .coin-icon-wrapper { 
      width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;
      border: 2px solid #6b2222; background: #2a0a0a;
    }
    .coin-icon { width: 32px; height: 32px; }

    .wallet-info h3 { display: flex; align-items: center; gap: 12px; font-family: 'Playfair Display', serif; font-size: 1.4rem; color: #ffffff; }
    .coin-badge { font-family: 'VT323', monospace; font-size: 18px; padding: 2px 10px; background: #4a1515; border: 1px solid #6b2222; color: #ffaaaa; }
    .wallet-address { color: #f0e0e0; font-size: 14px; font-family: 'VT323', monospace; margin-top: 6px; letter-spacing: 1px; word-break: break-all; }
    .wallet-price { color: #ffffff; font-size: 15px; margin-top: 6px; }
    .api-source { color: #e0d0d0; font-size: 13px; margin-top: 4px; font-style: italic; }

    .wallet-right { text-align: right; }
    .wallet-balance { font-family: 'VT323', monospace; font-size: 2.2rem; color: #ff7777; text-shadow: 0 0 10px rgba(255, 102, 102, 0.4); }
    .wallet-balance-coin { font-size: 1.2rem; color: #ffaaaa; margin-left: 8px; }
    .wallet-usd { color: #ffffff; font-size: 1.15rem; font-family: 'Courier Prime', monospace; }

    .loading-spinner { display: flex; align-items: center; gap: 8px; color: #ffffff; font-family: 'VT323', monospace; font-size: 20px; }
    .spinner { width: 16px; height: 16px; border: 2px solid #4a1515; border-top-color: #ff6666; border-radius: 50%; animation: spin 1s linear infinite; }
    .wallet-error { color: #ff7777; font-size: 18px; font-family: 'VT323', monospace; }

    /* Withdrawals Section */
    .withdrawals-container {
      background: linear-gradient(135deg, #251010 0%, #1a0808 100%);
      border: 1px solid #5a2020;
      padding: 16px;
    }

    .withdrawal-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #3d1515;
      flex-wrap: wrap;
      gap: 10px;
    }

    .withdrawal-item:last-child {
      border-bottom: none;
    }

    .withdrawal-item:hover {
      background: rgba(255, 102, 102, 0.05);
    }

    .withdrawal-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .withdrawal-coin-badge {
      font-family: 'VT323', monospace;
      font-size: 16px;
      padding: 4px 10px;
      background: #4a1515;
      border: 1px solid #6b2222;
      color: #ffaaaa;
      min-width: 50px;
      text-align: center;
    }

    .withdrawal-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .withdrawal-amount {
      font-family: 'VT323', monospace;
      font-size: 1.3rem;
      color: #ff7777;
    }

    .withdrawal-to {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: #aa8888;
    }

    .withdrawal-right {
      text-align: right;
    }

    .withdrawal-date {
      font-family: 'VT323', monospace;
      font-size: 14px;
      color: #cc9999;
      white-space: nowrap;
    }

    .withdrawal-txid {
      font-family: 'VT323', monospace;
      font-size: 11px;
      color: #886666;
    }

    .withdrawal-txid a {
      color: #aa7777;
      text-decoration: none;
    }

    .withdrawal-txid a:hover {
      color: #ffaaaa;
    }

    .no-withdrawals {
      text-align: center;
      padding: 20px;
      color: #aa8888;
      font-family: 'VT323', monospace;
      font-size: 18px;
    }

    /* Burn Wallet Section */
    .burn-container {
      background: linear-gradient(135deg, #251010 0%, #1a0808 100%);
      border: 1px solid #5a2020;
      padding: 16px;
    }

    .burn-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 2px solid #4a1515;
      margin-bottom: 8px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .burn-wallet-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .burn-wallet-label {
      font-family: 'Playfair Display', serif;
      font-size: 1.1rem;
      color: #ff9966;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .burn-icon {
      font-size: 1.3rem;
    }

    .burn-wallet-address {
      font-family: 'VT323', monospace;
      font-size: 13px;
      color: #aa8888;
      word-break: break-all;
    }

    .burn-wallet-address a {
      color: #aa8888;
      text-decoration: none;
    }

    .burn-wallet-address a:hover {
      color: #ffaaaa;
    }

    .burn-total {
      text-align: right;
    }

    .burn-total-label {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: #aa8888;
      text-transform: uppercase;
    }

    .burn-total-amount {
      font-family: 'VT323', monospace;
      font-size: 1.8rem;
      color: #ff9966;
      text-shadow: 0 0 10px rgba(255, 153, 102, 0.4);
    }

    .burn-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #3d1515;
      flex-wrap: wrap;
      gap: 10px;
      transition: background 0.2s;
    }

    .burn-item:last-child {
      border-bottom: none;
    }

    .burn-item:hover {
      background: rgba(255, 153, 102, 0.05);
    }

    .burn-item-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .burn-badge {
      font-family: 'VT323', monospace;
      font-size: 16px;
      padding: 4px 10px;
      background: #4a2515;
      border: 1px solid #6b3322;
      color: #ffbb99;
      min-width: 50px;
      text-align: center;
    }

    .burn-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .burn-amount {
      font-family: 'VT323', monospace;
      font-size: 1.3rem;
      color: #ff9966;
    }

    .burn-from {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: #aa8888;
    }

    .burn-from a {
      color: #aa8888;
      text-decoration: none;
    }

    .burn-from a:hover {
      color: #ffaaaa;
    }

    .burn-item-right {
      text-align: right;
    }

    .burn-date {
      font-family: 'VT323', monospace;
      font-size: 14px;
      color: #cc9999;
      white-space: nowrap;
    }

    .burn-txid {
      font-family: 'VT323', monospace;
      font-size: 11px;
      color: #886666;
    }

    .burn-txid a {
      color: #aa7777;
      text-decoration: none;
    }

    .burn-txid a:hover {
      color: #ffaaaa;
    }

    .no-burns {
      text-align: center;
      padding: 20px;
      color: #aa8888;
      font-family: 'VT323', monospace;
      font-size: 18px;
    }

    /* Pending Burns Section */
    .pending-container {
      background: linear-gradient(135deg, #1a1025 0%, #150a18 100%);
      border: 1px solid #5a3060;
      padding: 16px;
    }

    .pending-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 2px solid #4a2050;
      margin-bottom: 8px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .pending-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .pending-label {
      font-family: 'Playfair Display', serif;
      font-size: 1.1rem;
      color: #cc99ff;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pending-icon {
      font-size: 1.3rem;
    }

    .pending-subtitle {
      font-family: 'VT323', monospace;
      font-size: 13px;
      color: #aa88bb;
    }

    .pending-total {
      text-align: right;
    }

    .pending-total-label {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: #aa88bb;
      text-transform: uppercase;
    }

    .pending-total-amount {
      font-family: 'VT323', monospace;
      font-size: 1.8rem;
      color: #cc99ff;
      text-shadow: 0 0 10px rgba(204, 153, 255, 0.4);
    }

    .pending-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #3d2045;
      flex-wrap: wrap;
      gap: 10px;
      transition: background 0.2s;
    }

    .pending-item:last-child {
      border-bottom: none;
    }

    .pending-item:hover {
      background: rgba(204, 153, 255, 0.05);
    }

    .pending-item-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .pending-badge {
      font-family: 'VT323', monospace;
      font-size: 16px;
      padding: 4px 10px;
      background: #3a2045;
      border: 1px solid #5a3060;
      color: #ddaaff;
      min-width: 50px;
      text-align: center;
    }

    .pending-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .pending-amount {
      font-family: 'VT323', monospace;
      font-size: 1.3rem;
      color: #cc99ff;
    }

    .pending-coin {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: #aa88bb;
    }

    .pending-item-right {
      text-align: right;
    }

    .pending-date {
      font-family: 'VT323', monospace;
      font-size: 14px;
      color: #bb99cc;
      white-space: nowrap;
    }

    .pending-status {
      font-family: 'VT323', monospace;
      font-size: 12px;
      color: #ff9966;
    }

    .no-pending {
      text-align: center;
      padding: 20px;
      color: #88dd88;
      font-family: 'VT323', monospace;
      font-size: 18px;
    }

    .all-burned-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .chart-container { margin-top: 20px; padding: 16px; background: rgba(26, 8, 8, 0.8); border: 1px solid #3d1515; border-radius: 4px; }
    .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
    .chart-title { color: #ffaaaa; font-family: 'VT323', monospace; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; }

    .time-range-buttons { display: flex; gap: 6px; }
    .time-btn {
      padding: 6px 14px; background: #2a0a0a; border: 1px solid #5a2020;
      color: #cc9999; font-family: 'VT323', monospace; font-size: 16px;
      cursor: pointer; transition: all 0.2s; text-transform: uppercase;
    }
    .time-btn:hover { border-color: #aa4444; color: #ffaaaa; }
    .time-btn.active { background: #4a1515; border-color: #ff6666; color: #ffffff; box-shadow: 0 0 10px rgba(255, 102, 102, 0.3); }

    .chart-wrapper { height: 200px; position: relative; }
    .chart-loading { display: flex; align-items: center; justify-content: center; height: 200px; color: #aa7777; font-family: 'VT323', monospace; }

    footer { text-align: center; margin-top: 48px; padding-top: 32px; border-top: 1px solid #4a1515; color: #f0e0e0; font-size: 14px; line-height: 2; }
    footer a { color: #ffccaa; text-decoration: none; border-bottom: 1px dotted #ffccaa; }
    footer a:hover { color: #ffffff; }
    .footer-ornament { color: #ff6666; letter-spacing: 4px; margin-bottom: 12px; }

    @media (max-width: 640px) { 
      .container { padding: 24px 12px; }
      
      h1 { font-size: 1.8rem; letter-spacing: 2px; } 
      .subtitle { font-size: 0.85rem; letter-spacing: 2px; }
      .ornament { font-size: 18px; letter-spacing: 4px; }
      
      .total-card { padding: 20px 16px; }
      .total-amount { font-size: 2.2rem; } 
      .total-label { font-size: 12px; letter-spacing: 2px; }
      
      .refresh-btn { padding: 12px 20px; font-size: 12px; }
      
      .section-title { font-size: 1.2rem; letter-spacing: 2px; }
      
      .wallet-card { padding: 16px; }
      .wallet-inner { flex-direction: column; align-items: flex-start; gap: 12px; } 
      .wallet-right { text-align: left; width: 100%; }
      .wallet-balance { font-size: 1.8rem; }
      .wallet-address { font-size: 12px; }
      .coin-icon-wrapper { width: 40px; height: 40px; }
      .coin-icon { width: 24px; height: 24px; }
      
      .chart-container { padding: 12px; }
      .chart-header { flex-direction: column; align-items: flex-start; gap: 8px; }
      .chart-title { font-size: 14px; }
      .time-range-buttons { width: 100%; justify-content: space-between; }
      .time-btn { padding: 6px 10px; font-size: 14px; flex: 1; text-align: center; }
      
      /* Withdrawals mobile */
      .withdrawals-container { padding: 12px; }
      .withdrawal-item { padding: 10px 12px; flex-direction: column; align-items: flex-start; gap: 8px; }
      .withdrawal-left { width: 100%; }
      .withdrawal-right { width: 100%; text-align: left; display: flex; justify-content: space-between; align-items: center; }
      .withdrawal-amount { font-size: 1.1rem; }
      .withdrawal-coin-badge { font-size: 14px; min-width: 45px; }
      
      /* Burn section mobile */
      .burn-container { padding: 12px; }
      .burn-header { flex-direction: column; align-items: flex-start; gap: 8px; }
      .burn-total { text-align: left; margin-top: 8px; width: 100%; }
      .burn-total-amount { font-size: 1.5rem; }
      .burn-item { padding: 10px 12px; flex-direction: column; align-items: flex-start; gap: 8px; }
      .burn-item-left { width: 100%; }
      .burn-item-right { width: 100%; text-align: left; display: flex; justify-content: space-between; align-items: center; }
      .burn-amount { font-size: 1.1rem; }
      .burn-wallet-address { font-size: 11px; }
      
      /* Pending burns mobile */
      .pending-container { padding: 12px; }
      .pending-header { flex-direction: column; align-items: flex-start; gap: 8px; }
      .pending-total { text-align: left; width: 100%; }
      .pending-total-amount { font-size: 1.5rem; }
      .pending-item { padding: 10px 12px; flex-direction: column; align-items: flex-start; gap: 8px; }
      .pending-item-left { width: 100%; }
      .pending-item-right { width: 100%; text-align: left; display: flex; justify-content: space-between; align-items: center; }
      .pending-amount { font-size: 1.1rem; }
      
      /* Footer mobile */
      footer { font-size: 12px; }
      .footer-ornament { font-size: 14px; }
    }
    
    @media (max-width: 400px) {
      h1 { font-size: 1.5rem; }
      .total-amount { font-size: 1.8rem; }
      .wallet-balance { font-size: 1.5rem; }
      .time-btn { padding: 5px 6px; font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="bg-pattern"></div>
  <div class="container">
    <header>
      <div class="ornament">‚óÜ ‚óá ‚óÜ ‚óá ‚óÜ</div>
      <h1>Wallet Tracker</h1>
      <p class="subtitle">~ Cryptocurrency Portfolio Monitor ~</p>
    </header>

    <div class="total-card">
      <div class="corner corner-tl"></div>
      <div class="corner corner-tr"></div>
      <div class="corner corner-bl"></div>
      <div class="corner corner-br"></div>
      <p class="total-label">‚óà Total Portfolio Value ‚óà</p>
      <div class="total-value">
        <span class="total-amount" id="total-usd">$---</span>
        <span class="total-currency">USD</span>
      </div>
      <p class="last-updated" id="last-updated"></p>
      <p class="last-updated" id="next-refresh" style="font-size: 12px; margin-top: 8px; color: #aa8888;"></p>
    </div>

    <div class="refresh-container">
      <button class="refresh-btn" id="refresh-btn" onclick="manualRefresh()">
        <svg class="refresh-icon" id="refresh-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
        </svg>
        <span id="refresh-text">Refresh</span>
      </button>
    </div>

    <h2 class="section-title">‚óà Crypto Wallets ‚óà</h2>
    <div class="wallets" id="wallets"></div>

    <h2 class="section-title">‚óà Recent Withdrawals ‚óà</h2>
    <div class="withdrawals-container" id="withdrawals">
      <div class="loading-spinner" style="justify-content: center; padding: 20px;">
        <div class="spinner"></div>
        <span>Loading withdrawals...</span>
      </div>
    </div>

    <h2 class="section-title">‚è≥ Pending Burns ‚è≥</h2>
    <div class="pending-container" id="pending-burns">
      <div class="loading-spinner" style="justify-content: center; padding: 20px;">
        <div class="spinner"></div>
        <span>Calculating pending burns...</span>
      </div>
    </div>

    <h2 class="section-title">üî• QUAI Burn Wallet Deposits üî• <span id="burn-auto-refresh" style="font-size: 12px; color: #aa8888; font-family: 'VT323', monospace;">(auto-refreshes every 5min)</span></h2>
    <div class="burn-container" id="burn-deposits">
      <div class="loading-spinner" style="justify-content: center; padding: 20px;">
        <div class="spinner"></div>
        <span>Loading burn deposits...</span>
      </div>
    </div>

    <h2 class="section-title">‚óà QUAI Exchange Wallets ‚óà</h2>
    <div class="wallets" id="quai-wallets"></div>

    <footer>
      <div class="footer-ornament">‚Äî ‚óÜ ‚Äî</div>
      <p>RVN via <a href="https://cryptoscope.io" target="_blank">CryptoScope</a> ‚Ä¢ BCH via <a href="https://fullstack.cash" target="_blank">FullStack.cash</a></p>
      <p>LTC & DOGE via <a href="https://blockcypher.com" target="_blank">BlockCypher</a> ‚Ä¢ QUAI via <a href="https://rpc.quai.network" target="_blank">Quai RPC</a></p>
      <p>Burn tracking via <a href="https://quaiscan.io" target="_blank">QuaiScan</a> ‚Ä¢ Prices from <a href="https://coingecko.com" target="_blank">CoinGecko</a></p>
    </footer>
  </div>

  <script>
    const CORS_PROXIES = [
      'https://corsproxy.io/?',
      'https://api.allorigins.win/raw?url=',
      'https://proxy.cors.sh/'
    ];
    let currentProxyIndex = 0;
    
    // Helper function to fetch with CORS proxy fallback
    async function fetchWithProxy(url) {
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
        const proxy = CORS_PROXIES[proxyIndex];
        try {
          const response = await fetch(`${proxy}${encodeURIComponent(url)}`);
          const data = await response.json();
          
          // Check if rate limited
          if (data.message && data.message.includes('Rate limit')) {
            console.log(`Proxy ${proxy} rate limited, trying next...`);
            continue;
          }
          
          // Success - remember this proxy for next time
          currentProxyIndex = proxyIndex;
          return data;
        } catch (e) {
          console.log(`Proxy ${proxy} failed:`, e.message);
        }
      }
      throw new Error('All CORS proxies failed');
    }
    
    const CORS_PROXY = CORS_PROXIES[0]; // Keep for backwards compatibility
    const BURN_WALLET = '0x0050AF0000000000000000000000000000000000';
    
    const wallets = [
      { coin: 'RVN', name: 'Ravencoin', address: 'RXtpH2yp6AA6VvPVTuhCrqxYG7vCGEPMB5', geckoId: 'ravencoin' },
      { coin: 'BCH', name: 'Bitcoin Cash', address: 'qqqea0a7ryny69sskvx857apy3r6wt6w35524nm4xw', geckoId: 'bitcoin-cash' },
      { coin: 'LTC', name: 'Litecoin', address: 'ltc1qlg96gqruz4vu5w86z6rpqxt6ugqxrljxzpvcu8', geckoId: 'litecoin' },
      { coin: 'DOGE', name: 'Dogecoin', address: 'D6rnVyuuHB3x8et741kmXzFuZSTVnJQDke', geckoId: 'dogecoin' }
    ];

    const quaiWallets = [
      { exchange: 'MEXC', address: '0x006243e4eE6C2CF6F993036f27f0A88f265Ddb4a' },
      { exchange: 'GATE', address: '0x007e2F1a4709B812F339f22E18032118FBcc8987' }
    ];

    const coinIcons = {
      RVN: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M16 6l-8 5v10l8 5 8-5V11l-8-5zm0 2.5l5.5 3.5v7l-5.5 3.5-5.5-3.5v-7L16 8.5z" fill="#ffffff"/></svg>`,
      BCH: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M21.2 13.3c-.3-2-2.1-2.7-4.5-2.9V8h-1.8v2.3h-1.5V8h-1.8v2.4H9v1.8h1.3c.7 0 .9.4.9.7v7c0 .5-.3.7-.7.7H9l-.3 2h4.5v2.4h1.8v-2.4h1.5v2.4h1.8v-2.5c3-.2 5.1-.9 5.4-3.6.2-2.2-.8-3.2-2.5-3.6zm-5.9-1.2h2c1.3 0 2 .4 2 1.4 0 1-.7 1.4-2 1.4h-2v-2.8zm2.5 8h-2.5v-3.2h2.5c1.5 0 2.2.5 2.2 1.6 0 1.1-.7 1.6-2.2 1.6z" fill="#ffffff"/></svg>`,
      LTC: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M12.5 24h9.8l.8-3h-6.2l1.5-5.5 2.5-1-.5 1.5h2.5l1-3.5-2.5 1 1.5-5.5h-3.5l-2.5 9-2.5 1 .5-2h-2.5l-1.5 5.5 2.5-1-.8 3z" fill="#ffffff"/></svg>`,
      DOGE: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M13 9h4.5c4 0 6.5 2.5 6.5 7s-2.5 7-6.5 7H13V9zm3 2.5v9h1.5c2.5 0 4-1.5 4-4.5s-1.5-4.5-4-4.5H16zm-3 3h6v2h-6v-2z" fill="#ffffff"/></svg>`,
      QUAI: `<svg viewBox="0 0 32 32" class="coin-icon"><circle cx="16" cy="16" r="16" fill="#8b0000"/><path d="M16 6C10.5 6 6 10.5 6 16s4.5 10 10 10 10-4.5 10-10S21.5 6 16 6zm0 3c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zm0 2.5c-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5z" fill="#ffffff"/></svg>`
    };

    let balances = {}, prices = {}, quaiBalances = {}, quaiCharts = {}, quaiHistoryData = {}, selectedTimeRange = {};
    let loadedWithdrawals = [], loadedBurnDeposits = [], lastBurnTime = null;
    let withdrawalsLoaded = false, burnDepositsLoaded = false;
    let lastBurnRefreshTime = null;

    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache

    function getCachedHistory(exchange, days) {
      try {
        const cached = localStorage.getItem(`quai_history_${exchange}_${days}`);
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < CACHE_DURATION) {
            console.log(`Using cached ${days}D data for ${exchange}`);
            return data;
          }
        }
      } catch (e) { console.error('Cache read error:', e); }
      return null;
    }

    function setCachedHistory(exchange, days, data) {
      try {
        localStorage.setItem(`quai_history_${exchange}_${days}`, JSON.stringify({
          data: data,
          timestamp: Date.now()
        }));
      } catch (e) { console.error('Cache write error:', e); }
    }

    function getCachedWithdrawals() {
      try {
        const cached = localStorage.getItem('withdrawals_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < CACHE_DURATION) {
            console.log('Using cached withdrawals');
            return data;
          }
        }
      } catch (e) { console.error('Withdrawals cache read error:', e); }
      return null;
    }

    function setCachedWithdrawals(data) {
      try {
        localStorage.setItem('withdrawals_cache', JSON.stringify({
          data: data,
          timestamp: Date.now()
        }));
      } catch (e) { console.error('Withdrawals cache write error:', e); }
    }

    function getCachedBurnDeposits() {
      try {
        const cached = localStorage.getItem('burn_deposits_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < CACHE_DURATION) {
            console.log('Using cached burn deposits');
            return data;
          }
        }
      } catch (e) { console.error('Burn deposits cache read error:', e); }
      return null;
    }

    function setCachedBurnDeposits(data) {
      try {
        localStorage.setItem('burn_deposits_cache', JSON.stringify({
          data: data,
          timestamp: Date.now()
        }));
      } catch (e) { console.error('Burn deposits cache write error:', e); }
    }

    function renderWallets() {
      document.getElementById('wallets').innerHTML = wallets.map((wallet, index) => `
        <div class="wallet-card" data-index="0${index + 1}">
          <div class="wallet-inner">
            <div class="wallet-left">
              <div class="coin-icon-wrapper">${coinIcons[wallet.coin]}</div>
              <div class="wallet-info">
                <h3>${wallet.name} <span class="coin-badge">${wallet.coin}</span></h3>
                <p class="wallet-address">${wallet.address}</p>
                <p class="wallet-price" id="price-${wallet.coin}">Loading price...</p>
                <p class="api-source" id="source-${wallet.coin}"></p>
              </div>
            </div>
            <div class="wallet-right" id="balance-${wallet.coin}">
              <div class="loading-spinner"><div class="spinner"></div><span>LOADING...</span></div>
            </div>
          </div>
        </div>
      `).join('');
    }

    function renderQuaiWallets() {
      document.getElementById('quai-wallets').innerHTML = quaiWallets.map((wallet, index) => {
        selectedTimeRange[wallet.exchange] = 1;
        return `
        <div class="wallet-card" data-index="0${index + 1}">
          <div class="wallet-inner">
            <div class="wallet-left">
              <div class="coin-icon-wrapper">${coinIcons.QUAI}</div>
              <div class="wallet-info">
                <h3>${wallet.exchange} <span class="coin-badge">QUAI</span></h3>
                <p class="wallet-address">${wallet.address}</p>
                <p class="api-source">via Quai RPC</p>
              </div>
            </div>
            <div class="wallet-right" id="quai-balance-${wallet.exchange}">
              <div class="loading-spinner"><div class="spinner"></div><span>LOADING...</span></div>
            </div>
          </div>
          <div class="chart-container">
            <div class="chart-header">
              <p class="chart-title">Balance History <span id="chart-info-${wallet.exchange}" style="font-size: 14px; color: #aa7777;"></span></p>
              <div class="time-range-buttons">
                <button class="time-btn active" data-exchange="${wallet.exchange}" data-days="1" onclick="changeTimeRange('${wallet.exchange}', 1)">24H</button>
                <button class="time-btn" data-exchange="${wallet.exchange}" data-days="7" onclick="changeTimeRange('${wallet.exchange}', 7)">7D</button>
                <button class="time-btn" data-exchange="${wallet.exchange}" data-days="30" onclick="changeTimeRange('${wallet.exchange}', 30)">30D</button>
                <button class="time-btn" data-exchange="${wallet.exchange}" data-days="90" onclick="changeTimeRange('${wallet.exchange}', 90)">90D</button>
              </div>
            </div>
            <div class="chart-wrapper"><canvas id="chart-${wallet.exchange}"></canvas></div>
            <div class="chart-loading" id="chart-loading-${wallet.exchange}">
              <div class="spinner" style="margin-right: 8px;"></div>Loading chart data...
            </div>
          </div>
        </div>
      `}).join('');
    }

    async function changeTimeRange(exchange, days) {
      selectedTimeRange[exchange] = days;
      document.querySelectorAll(`.time-btn[data-exchange="${exchange}"]`).forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.days) === days);
      });
      
      // Check cache first
      const cachedHistory = getCachedHistory(exchange, days);
      if (cachedHistory) {
        quaiHistoryData[exchange] = cachedHistory;
        createChart(exchange, cachedHistory, days);
        return;
      }
      
      // Need to refetch data for new time range
      const wallet = quaiWallets.find(w => w.exchange === exchange);
      if (wallet) {
        const loadingEl = document.getElementById(`chart-loading-${exchange}`);
        const canvas = document.getElementById(`chart-${exchange}`);
        if (loadingEl) {
          loadingEl.style.display = 'flex';
          loadingEl.innerHTML = `<div class="spinner" style="margin-right: 8px;"></div>Loading ${days === 1 ? '24H' : days + 'D'} history...`;
        }
        if (canvas) canvas.style.display = 'none';
        
        const history = await fetchQuaiBalanceHistory(wallet.address, days);
        quaiHistoryData[exchange] = history;
        setCachedHistory(exchange, days, history);
        createChart(exchange, history, days);
      }
    }

    async function fetchPrices() {
      try {
        const ids = [...wallets.map(w => w.geckoId), 'quai-network'].join(',');
        const data = await (await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`)).json();
        wallets.forEach(wallet => {
          if (data[wallet.geckoId]) {
            prices[wallet.coin] = data[wallet.geckoId].usd;
            document.getElementById(`price-${wallet.coin}`).textContent = 
              `$${prices[wallet.coin].toLocaleString(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 6 })} / ${wallet.coin}`;
          }
        });
        if (data['quai-network']) prices['QUAI'] = data['quai-network'].usd;
      } catch (err) { console.error('Failed to fetch prices:', err); }
    }

    async function fetchRVN(address) {
      const data = await fetchWithProxy(`https://rvn.cryptoscope.io/api/getaddress/?address=${address}`);
      if (data?.balance !== undefined) return { balance: parseFloat(data.balance), source: 'CryptoScope' };
      throw new Error('RVN API failed');
    }

    async function fetchBCH(address) {
      const data = await fetchWithProxy(`https://bchn.fullstack.cash/v5/electrumx/balance/bitcoincash:${address}`);
      if (data.balance?.confirmed !== undefined) return { balance: (data.balance.confirmed + (data.balance.unconfirmed || 0)) / 1e8, source: 'FullStack.cash' };
      throw new Error('BCH API failed');
    }

    async function fetchLTC(address) {
      // Try direct first, then proxy
      try {
        const response = await fetch(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/balance`);
        if (response.ok) {
          const data = await response.json();
          return { balance: data.balance / 1e8, source: 'BlockCypher' };
        }
      } catch (e) {
        console.log('LTC direct fetch failed, trying proxy...');
      }
      // Fallback to proxy
      const data = await fetchWithProxy(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/balance`);
      return { balance: data.balance / 1e8, source: 'BlockCypher' };
    }

    async function fetchDOGE(address) {
      // Try direct first, then proxy
      try {
        const response = await fetch(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/balance`);
        if (response.ok) {
          const data = await response.json();
          return { balance: data.balance / 1e8, source: 'BlockCypher' };
        }
      } catch (e) {
        console.log('DOGE direct fetch failed, trying proxy...');
      }
      // Fallback to proxy
      const data = await fetchWithProxy(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/balance`);
      return { balance: data.balance / 1e8, source: 'BlockCypher' };
    }

    // Fetch historical price for a specific coin at a specific date
    async function fetchHistoricalCoinPrice(geckoId, date) {
      try {
        // Format date as dd-mm-yyyy for CoinGecko
        const d = new Date(date);
        const dateStr = `${d.getDate().toString().padStart(2, '0')}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getFullYear()}`;
        
        const url = `https://api.coingecko.com/api/v3/coins/${geckoId}/history?date=${dateStr}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.market_data && data.market_data.current_price && data.market_data.current_price.usd) {
          return data.market_data.current_price.usd;
        }
        return null;
      } catch (err) {
        console.error(`Failed to fetch historical price for ${geckoId}:`, err);
        return null;
      }
    }

    // Fetch historical QUAI prices for a date range
    async function fetchHistoricalQuaiPrices(startTimestamp, endTimestamp) {
      try {
        // CoinGecko market_chart/range endpoint
        const url = `https://api.coingecko.com/api/v3/coins/quai-network/market_chart/range?vs_currency=usd&from=${Math.floor(startTimestamp/1000)}&to=${Math.floor(endTimestamp/1000)}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.prices && Array.isArray(data.prices)) {
          console.log(`Fetched ${data.prices.length} historical QUAI price points`);
          return data.prices; // Array of [timestamp_ms, price]
        }
        return null;
      } catch (err) {
        console.error('Failed to fetch historical QUAI prices:', err);
        return null;
      }
    }

    // Find the closest price to a given timestamp
    function findPriceAtTime(priceHistory, targetTimestamp) {
      if (!priceHistory || priceHistory.length === 0) return null;
      
      let closest = priceHistory[0];
      let closestDiff = Math.abs(priceHistory[0][0] - targetTimestamp);
      
      for (const [ts, price] of priceHistory) {
        const diff = Math.abs(ts - targetTimestamp);
        if (diff < closestDiff) {
          closestDiff = diff;
          closest = [ts, price];
        }
      }
      
      return closest[1]; // Return the price
    }

    // Burn wallet tracking functions
    async function fetchBurnWalletBalance() {
      try {
        const response = await fetch('https://rpc.quai.network/cyprus1/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'quai_getBalance',
            params: [BURN_WALLET, 'latest'],
            id: 1
          })
        });
        const data = await response.json();
        if (data.result) {
          return parseInt(data.result, 16) / 1e18;
        }
        return 0;
      } catch (err) {
        console.error('Failed to fetch burn wallet balance:', err);
        return 0;
      }
    }

    async function fetchBurnDeposits(forceRefresh = false) {
      const container = document.getElementById('burn-deposits');
      
      // Show loading state when forcing refresh
      if (forceRefresh) {
        container.innerHTML = `
          <div class="loading-spinner" style="justify-content: center; padding: 20px;">
            <div class="spinner"></div>
            <span>Loading burn deposits...</span>
          </div>
        `;
      }
      
      // Check cache first (unless forcing refresh)
      if (!forceRefresh) {
        const cached = getCachedBurnDeposits();
        if (cached) {
          renderBurnDeposits(cached.deposits, cached.totalBalance, container);
          return;
        }
      }
      
      // Show loading indicator
      container.innerHTML = `
        <div class="loading-spinner" style="justify-content: center; padding: 20px;">
          <div class="spinner"></div>
          <span>Loading burn deposits...</span>
        </div>
      `;
      
      try {
        console.log('Fetching burn wallet deposits...');
        
        // Get total balance first
        const totalBalance = await fetchBurnWalletBalance();
        
        // Try QuaiScan API - common patterns for block explorers
        let deposits = [];
        
        // Try the Blockscout-style API (common for EVM explorers)
        try {
          const data = await fetchWithProxy(`https://quaiscan.io/api?module=account&action=txlist&address=${BURN_WALLET}&sort=desc&page=1&offset=10`);
          
          console.log('QuaiScan API response:', data);
          
          if (data.result && Array.isArray(data.result)) {
            deposits = data.result
              .filter(tx => tx.to && tx.to.toLowerCase() === BURN_WALLET.toLowerCase())
              .slice(0, 6)
              .map(tx => ({
                amount: parseInt(tx.value) / 1e18,
                from: tx.from,
                date: new Date(parseInt(tx.timeStamp) * 1000),
                txid: tx.hash,
                blockNumber: tx.blockNumber
              }));
          }
        } catch (apiErr) {
          console.log('Blockscout API failed, trying alternative:', apiErr);
        }
        
        // If first API didn't work, try v2 API format
        if (deposits.length === 0) {
          try {
            const data = await fetchWithProxy(`https://quaiscan.io/api/v2/addresses/${BURN_WALLET}/transactions?type=coin_transfer`);
            
            console.log('QuaiScan v2 API response:', data);
            
            if (data.items && Array.isArray(data.items)) {
              deposits = data.items
                .filter(tx => tx.to && tx.to.hash && tx.to.hash.toLowerCase() === BURN_WALLET.toLowerCase())
                .slice(0, 6)
                .map(tx => ({
                  amount: parseInt(tx.value) / 1e18,
                  from: tx.from?.hash || 'Unknown',
                  date: new Date(tx.timestamp),
                  txid: tx.hash,
                  blockNumber: tx.block
                }));
            }
          } catch (v2Err) {
            console.log('V2 API also failed:', v2Err);
          }
        }
        
        // If APIs didn't work, try fetching recent blocks and looking for transfers
        if (deposits.length === 0) {
          console.log('Attempting RPC-based transaction discovery...');
          deposits = await fetchBurnDepositsViaRPC();
        }
        
        // Fetch historical QUAI prices for the burn timestamps
        if (deposits.length > 0) {
          const timestamps = deposits.map(d => d.date.getTime());
          const minTime = Math.min(...timestamps) - (24 * 60 * 60 * 1000); // 1 day buffer before
          const maxTime = Math.max(...timestamps) + (24 * 60 * 60 * 1000); // 1 day buffer after
          
          const priceHistory = await fetchHistoricalQuaiPrices(minTime, maxTime);
          
          if (priceHistory) {
            // Attach historical USD value to each deposit
            deposits = deposits.map(d => {
              const priceAtTime = findPriceAtTime(priceHistory, d.date.getTime());
              const usdValueAtTime = priceAtTime ? d.amount * priceAtTime : null;
              console.log(`Burn ${d.txid.slice(0,8)}: ${d.amount.toFixed(2)} QUAI @ $${priceAtTime?.toFixed(4) || 'N/A'} = $${usdValueAtTime?.toFixed(2) || 'N/A'}`);
              return {
                ...d,
                priceAtTime,
                usdValueAtTime
              };
            });
          } else {
            console.log('Could not fetch historical prices, using current price as fallback');
          }
        }
        
        // Cache the results
        const cacheData = {
          deposits: deposits.map(d => ({
            ...d,
            date: d.date.toISOString()
          })),
          totalBalance
        };
        setCachedBurnDeposits(cacheData);
        
        renderBurnDeposits(deposits, totalBalance, container);
        
      } catch (err) {
        console.error('Failed to fetch burn deposits:', err);
        container.innerHTML = '<div class="no-burns">Failed to load burn deposits. <a href="https://quaiscan.io/address/' + BURN_WALLET + '" target="_blank" style="color: #ffaaaa;">View on QuaiScan ‚Üí</a></div>';
        burnDepositsLoaded = true;
        updatePendingBurns();
      }
    }

    async function fetchBurnDepositsViaRPC() {
      // This is a fallback method - fetch recent blocks and check for transfers to burn address
      // Note: This is less efficient but works if the explorer API is unavailable
      const deposits = [];
      
      try {
        // Get current block number
        const blockResponse = await fetch('https://rpc.quai.network/cyprus1/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'quai_blockNumber',
            params: [],
            id: 1
          })
        });
        const blockData = await blockResponse.json();
        const currentBlock = parseInt(blockData.result, 16);
        
        // Check last 100 blocks for transactions to burn address
        for (let i = 0; i < 100 && deposits.length < 6; i++) {
          const blockNum = currentBlock - i;
          const blockHex = '0x' + blockNum.toString(16);
          
          try {
            const txResponse = await fetch('https://rpc.quai.network/cyprus1/', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                jsonrpc: '2.0',
                method: 'quai_getBlockByNumber',
                params: [blockHex, true],
                id: 1
              })
            });
            const txData = await txResponse.json();
            
            if (txData.result && txData.result.transactions) {
              for (const tx of txData.result.transactions) {
                if (tx.to && tx.to.toLowerCase() === BURN_WALLET.toLowerCase()) {
                  const value = parseInt(tx.value, 16) / 1e18;
                  if (value > 0) {
                    // Estimate timestamp based on block number
                    const blocksFromNow = currentBlock - blockNum;
                    const msFromNow = blocksFromNow * 5000; // ~5 seconds per block
                    
                    deposits.push({
                      amount: value,
                      from: tx.from,
                      date: new Date(Date.now() - msFromNow),
                      txid: tx.hash,
                      blockNumber: blockNum
                    });
                    
                    if (deposits.length >= 6) break;
                  }
                }
              }
            }
          } catch (blockErr) {
            console.log('Block fetch error:', blockErr);
          }
          
          // Small delay to avoid rate limiting
          if (i % 10 === 0) await new Promise(r => setTimeout(r, 100));
        }
      } catch (err) {
        console.error('RPC-based burn deposit fetch failed:', err);
      }
      
      return deposits;
    }

    function renderBurnDeposits(deposits, totalBalance, container) {
      const quaiPrice = prices['QUAI'] || 0;
      const totalUsd = totalBalance * quaiPrice;
      
      // Track refresh time
      lastBurnRefreshTime = new Date();
      updateBurnRefreshIndicator();
      
      // Store for pending burns calculation
      loadedBurnDeposits = deposits;
      burnDepositsLoaded = true;
      if (deposits && deposits.length > 0) {
        // Find the most recent burn time
        const sortedBurns = [...deposits].sort((a, b) => {
          const dateA = a.date instanceof Date ? a.date : new Date(a.date);
          const dateB = b.date instanceof Date ? b.date : new Date(b.date);
          return dateB - dateA;
        });
        lastBurnTime = sortedBurns[0].date instanceof Date ? sortedBurns[0].date : new Date(sortedBurns[0].date);
      }
      
      // Update pending burns display
      updatePendingBurns();
      
      let html = `
        <div class="burn-header">
          <div class="burn-wallet-info">
            <div class="burn-wallet-label">
              <span class="burn-icon">üî•</span>
              QUAI Burn Address
            </div>
            <div class="burn-wallet-address">
              <a href="https://quaiscan.io/address/${BURN_WALLET}" target="_blank">${BURN_WALLET}</a>
            </div>
          </div>
          <div class="burn-total">
            <div class="burn-total-label">Total Burned</div>
            <div class="burn-total-amount">${totalBalance.toLocaleString(undefined, { maximumFractionDigits: 2 })} QUAI</div>
            ${quaiPrice > 0 ? `<div style="color: #cc9999; font-family: 'VT323', monospace; font-size: 14px;">‚âà $${totalUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })}</div>` : ''}
          </div>
        </div>
      `;
      
      if (!deposits || deposits.length === 0) {
        html += '<div class="no-burns">No recent deposits found. <a href="https://quaiscan.io/address/' + BURN_WALLET + '" target="_blank" style="color: #ffaaaa;">View on QuaiScan ‚Üí</a></div>';
      } else {
        html += deposits.map(d => {
          const date = d.date instanceof Date ? d.date : new Date(d.date);
          const fromShort = d.from ? `${d.from.slice(0, 10)}...${d.from.slice(-6)}` : 'Unknown';
          // Use historical price if available, otherwise current price
          const hasHistoricalPrice = d.usdValueAtTime != null;
          const usdValue = hasHistoricalPrice ? d.usdValueAtTime : (d.amount * quaiPrice);
          const priceLabel = hasHistoricalPrice ? `$${usdValue.toLocaleString(undefined, { maximumFractionDigits: 2 })} (at time)` : `‚âà $${usdValue.toLocaleString(undefined, { maximumFractionDigits: 2 })} (now)`;
          
          return `
            <div class="burn-item">
              <div class="burn-item-left">
                <span class="burn-badge">üî•</span>
                <div class="burn-item-info">
                  <span class="burn-amount">+${d.amount.toLocaleString(undefined, { maximumFractionDigits: 4 })} QUAI</span>
                  ${usdValue > 0 ? `<span style="color: #aa8888; font-family: 'VT323', monospace; font-size: 12px;">${priceLabel}</span>` : ''}
                  <span class="burn-from">From: <a href="https://quaiscan.io/address/${d.from}" target="_blank">${fromShort}</a></span>
                </div>
              </div>
              <div class="burn-item-right">
                <div class="burn-date">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} ${date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div>
                <div class="burn-txid"><a href="https://quaiscan.io/tx/${d.txid}" target="_blank">${d.txid.slice(0, 12)}...${d.txid.slice(-6)}</a></div>
              </div>
            </div>
          `;
        }).join('');
      }
      
      container.innerHTML = html;
    }

    // Withdrawal tracking functions
    async function fetchRVNWithdrawals(address) {
      try {
        // Fetch 400 transactions to find withdrawals
        const withdrawals = [];
        let foundWithdrawals = 0;
        
        const data = await fetchWithProxy(`https://blockbook.ravencoin.org/api/v2/address/${address}?details=txids&pageSize=400&page=1`);
        console.log('RVN Blockbook:', data.txids?.length, 'txids');
        
        if (!data || !data.txids || data.txids.length === 0) return [];
        
        // Check each transaction
        for (const txid of data.txids) {
          if (foundWithdrawals >= 20) break; // Limit total withdrawals found
          
          try {
            const tx = await fetchWithProxy(`https://blockbook.ravencoin.org/api/v2/tx/${txid}`);
            
            // Check if our address is in vin (inputs = we're sending)
            const isInput = tx.vin?.some(vin => vin.addresses?.includes(address));
            
            if (isInput) {
              // Calculate amount sent to other addresses
              const sentAmount = tx.vout
                ?.filter(vout => !vout.addresses?.includes(address))
                .reduce((sum, vout) => sum + parseInt(vout.value || 0), 0) || 0;
              
              if (sentAmount > 0) {
                console.log('RVN withdrawal found:', txid.slice(0, 10), sentAmount / 1e8);
                withdrawals.push({
                  coin: 'RVN',
                  amount: sentAmount / 1e8,
                  date: new Date(tx.blockTime * 1000),
                  txid: tx.txid,
                  explorer: `https://blockbook.ravencoin.org/tx/${tx.txid}`
                });
                foundWithdrawals++;
              }
            }
            
            await new Promise(r => setTimeout(r, 100));
          } catch (e) { console.error('RVN tx fetch error:', e); }
        }
        
        console.log('RVN total withdrawals found:', withdrawals.length);
        return withdrawals;
      } catch (err) { console.error('RVN withdrawals error:', err); return []; }
    }

    async function fetchBCHWithdrawals(address) {
      try {
        const fullAddress = `bitcoincash:${address}`;
        // Get transaction history from FullStack
        const data = await fetchWithProxy(`https://bchn.fullstack.cash/v5/electrumx/transactions/${fullAddress}`);
        
        console.log('BCH tx list:', data);
        
        if (!data || !data.transactions) return [];
        
        const withdrawals = [];
        // Get details for recent transactions
        for (const tx of data.transactions.slice(0, 6)) {
          try {
            const txResult = await fetchWithProxy(`https://bchn.fullstack.cash/v5/electrumx/tx/data/${tx.tx_hash}`);
            
            // Data is nested in 'details' object
            const txData = txResult.details || txResult;
            
            // Log first vin to see structure
            if (txData.vin && txData.vin[0]) {
              console.log('BCH vin[0] full:', JSON.stringify(txData.vin[0]));
            }
            
            if (txData && txData.vout) {
              // Check if our address appears in any output (receiving)
              const receivedAmount = txData.vout
                .filter(vout => {
                  const addrs = vout.scriptPubKey?.addresses || [];
                  return addrs.some(a => a.includes(address));
                })
                .reduce((sum, vout) => sum + (parseFloat(vout.value) || 0), 0);
              
              // Check total output value
              const totalOut = txData.vout.reduce((sum, vout) => sum + (parseFloat(vout.value) || 0), 0);
              
              console.log('BCH tx:', tx.tx_hash.slice(0,10), 'received:', receivedAmount, 'totalOut:', totalOut);
              
              // If we received 0 from this tx, it's likely an outgoing tx
              // (our address was in inputs, sending to others)
              if (receivedAmount === 0 && totalOut > 0) {
                withdrawals.push({
                  coin: 'BCH',
                  amount: totalOut,
                  date: txData.blocktime ? new Date(txData.blocktime * 1000) : new Date(),
                  txid: tx.tx_hash,
                  explorer: `https://blockchair.com/bitcoin-cash/transaction/${tx.tx_hash}`
                });
              }
            }
            await new Promise(r => setTimeout(r, 500));
          } catch (e) { console.error('BCH tx detail error:', e); }
        }
        return withdrawals;
      } catch (err) { console.error('BCH withdrawals error:', err); return []; }
    }

    async function fetchLTCWithdrawals(address) {
      try {
        let data;
        // Try direct first, then proxy
        try {
          const response = await fetch(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/full?limit=20`);
          if (response.ok) {
            data = await response.json();
          } else {
            throw new Error('Direct fetch failed');
          }
        } catch (e) {
          console.log('LTC withdrawals direct fetch failed, trying proxy...');
          data = await fetchWithProxy(`https://api.blockcypher.com/v1/ltc/main/addrs/${address}/full?limit=20`);
        }
        
        console.log('LTC full tx data:', data);
        if (!data || !data.txs) return [];
        
        const withdrawals = [];
        for (const tx of data.txs) {
          // Check if our address is in inputs (we're sending)
          const isInput = tx.inputs?.some(input => 
            input.addresses && input.addresses.includes(address)
          );
          
          if (isInput) {
            // Calculate how much was sent out (to addresses that aren't ours)
            const sentAmount = tx.outputs
              ?.filter(out => !out.addresses?.includes(address))
              .reduce((sum, out) => sum + (out.value || 0), 0) || 0;
            
            if (sentAmount > 0) {
              withdrawals.push({
                coin: 'LTC',
                amount: sentAmount / 1e8,
                date: new Date(tx.confirmed || tx.received),
                txid: tx.hash,
                explorer: `https://blockchair.com/litecoin/transaction/${tx.hash}`
              });
            }
          }
        }
        return withdrawals;
      } catch (err) { console.error('LTC withdrawals error:', err); return []; }
    }

    async function fetchDOGEWithdrawals(address) {
      try {
        let data;
        // Try direct first, then proxy
        try {
          const response = await fetch(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/full?limit=20`);
          if (response.ok) {
            data = await response.json();
          } else {
            throw new Error('Direct fetch failed');
          }
        } catch (e) {
          console.log('DOGE withdrawals direct fetch failed, trying proxy...');
          data = await fetchWithProxy(`https://api.blockcypher.com/v1/doge/main/addrs/${address}/full?limit=20`);
        }
        
        console.log('DOGE full tx data:', data);
        if (!data || !data.txs) return [];
        
        const withdrawals = [];
        for (const tx of data.txs) {
          // Check if our address is in inputs (we're sending)
          const isInput = tx.inputs?.some(input => 
            input.addresses && input.addresses.includes(address)
          );
          
          if (isInput) {
            // Calculate how much was sent out (to addresses that aren't ours)
            const sentAmount = tx.outputs
              ?.filter(out => !out.addresses?.includes(address))
              .reduce((sum, out) => sum + (out.value || 0), 0) || 0;
            
            if (sentAmount > 0) {
              withdrawals.push({
                coin: 'DOGE',
                amount: sentAmount / 1e8,
                date: new Date(tx.confirmed || tx.received),
                txid: tx.hash,
                explorer: `https://blockchair.com/dogecoin/transaction/${tx.hash}`
              });
            }
          }
        }
        return withdrawals;
      } catch (err) { console.error('DOGE withdrawals error:', err); return []; }
    }

    async function fetchAllWithdrawals(forceRefresh = false) {
      const container = document.getElementById('withdrawals');
      
      // Show loading state when forcing refresh
      if (forceRefresh) {
        container.innerHTML = `
          <div class="loading-spinner" style="justify-content: center; padding: 20px;">
            <div class="spinner"></div>
            <span>Loading withdrawals...</span>
          </div>
        `;
      }
      
      // Check cache first (unless forcing refresh)
      if (!forceRefresh) {
        const cached = getCachedWithdrawals();
        if (cached) {
          // Handle both old format (array) and new format (object with withdrawals)
          const isNewFormat = cached.withdrawals !== undefined;
          const withdrawals = isNewFormat ? cached.withdrawals : cached;
          const failedApis = isNewFormat ? (cached.failedApis || []) : [];
          const allApisSucceeded = isNewFormat ? cached.allApisSucceeded : true;
          
          if (withdrawals && withdrawals.length > 0 && allApisSucceeded) {
            renderWithdrawals(withdrawals, container, failedApis);
            return;
          } else if (!allApisSucceeded) {
            console.log('Cached data was incomplete, refetching...');
          }
        }
      }
      
      // Show loading indicator
      container.innerHTML = `
        <div class="loading-spinner" style="justify-content: center; padding: 20px;">
          <div class="spinner"></div>
          <span>Loading withdrawals...</span>
        </div>
      `;
      
      try {
        console.log('Fetching withdrawals...');
        
        // Track which APIs succeeded
        const apiResults = { RVN: null, BCH: null, LTC: null, DOGE: null };
        const failedApis = [];
        
        try {
          apiResults.RVN = await fetchRVNWithdrawals(wallets.find(w => w.coin === 'RVN').address);
          console.log('RVN withdrawals:', apiResults.RVN);
        } catch (e) {
          console.error('RVN API failed:', e);
          failedApis.push('RVN');
          apiResults.RVN = [];
        }
        
        try {
          apiResults.BCH = await fetchBCHWithdrawals(wallets.find(w => w.coin === 'BCH').address);
          console.log('BCH withdrawals:', apiResults.BCH);
        } catch (e) {
          console.error('BCH API failed:', e);
          failedApis.push('BCH');
          apiResults.BCH = [];
        }
        
        try {
          apiResults.LTC = await fetchLTCWithdrawals(wallets.find(w => w.coin === 'LTC').address);
          console.log('LTC withdrawals:', apiResults.LTC);
        } catch (e) {
          console.error('LTC API failed:', e);
          failedApis.push('LTC');
          apiResults.LTC = [];
        }
        
        try {
          apiResults.DOGE = await fetchDOGEWithdrawals(wallets.find(w => w.coin === 'DOGE').address);
          console.log('DOGE withdrawals:', apiResults.DOGE);
        } catch (e) {
          console.error('DOGE API failed:', e);
          failedApis.push('DOGE');
          apiResults.DOGE = [];
        }
        
        // Check if any API returned empty (might be failure)
        if (apiResults.RVN.length === 0) failedApis.push('RVN');
        if (apiResults.BCH.length === 0 && !failedApis.includes('BCH')) failedApis.push('BCH');
        if (apiResults.LTC.length === 0 && !failedApis.includes('LTC')) failedApis.push('LTC');
        if (apiResults.DOGE.length === 0 && !failedApis.includes('DOGE')) failedApis.push('DOGE');
        
        // Remove duplicates
        const uniqueFailedApis = [...new Set(failedApis)];
        
        let allWithdrawals = [...apiResults.RVN, ...apiResults.BCH, ...apiResults.LTC, ...apiResults.DOGE]
          .filter(w => w.date && !isNaN(w.date.getTime()))
          .sort((a, b) => b.date - a.date)
          .slice(0, 20);
        
        console.log('All withdrawals:', allWithdrawals);
        if (uniqueFailedApis.length > 0) {
          console.warn('Some APIs may have failed or returned empty:', uniqueFailedApis);
        }
        
        // Only cache if all APIs succeeded (no empty results except genuinely no withdrawals)
        const allApisSucceeded = uniqueFailedApis.length === 0;
        
        // Cache the results (convert dates to ISO strings for serialization)
        const cacheData = {
          withdrawals: allWithdrawals.map(w => ({
            ...w,
            date: w.date.toISOString()
          })),
          allApisSucceeded,
          failedApis: uniqueFailedApis
        };
        
        // Only cache if we got complete data, or cache for shorter time if incomplete
        if (allApisSucceeded) {
          setCachedWithdrawals(cacheData);
        } else {
          console.log('Not caching incomplete withdrawal data - some APIs failed');
        }
        
        renderWithdrawals(allWithdrawals, container, uniqueFailedApis);
        
      } catch (err) {
        console.error('Failed to fetch withdrawals:', err);
        container.innerHTML = '<div class="no-withdrawals">Failed to load withdrawals</div>';
        withdrawalsLoaded = true;
        updatePendingBurns();
      }
    }

    function renderWithdrawals(withdrawals, container, failedApis = []) {
      // Store for pending burns calculation
      loadedWithdrawals = withdrawals;
      withdrawalsLoaded = true;
      
      // Update pending burns display
      updatePendingBurns();
      
      if (withdrawals.length === 0) {
        container.innerHTML = '<div class="no-withdrawals">No recent withdrawals found</div>';
        return;
      }
      
      // Show warning if some APIs failed
      let warningHtml = '';
      if (failedApis.length > 0) {
        warningHtml = `
          <div style="background: #3d2020; border: 1px solid #6b3333; padding: 10px 16px; margin-bottom: 8px; color: #ffaaaa; font-family: 'VT323', monospace; font-size: 14px;">
            ‚ö†Ô∏è Warning: ${failedApis.join(', ')} withdrawal data may be incomplete. Pending burns calculation may be inaccurate.
          </div>
        `;
      }
      
      container.innerHTML = warningHtml + withdrawals.map(w => {
        const date = w.date instanceof Date ? w.date : new Date(w.date);
        const currentPrice = prices[w.coin] || 0;
        const usdValue = w.amount * currentPrice;
        const priceLabel = currentPrice > 0 ? `‚âà $${usdValue.toLocaleString(undefined, { maximumFractionDigits: 2 })}` : '';
        
        return `
          <div class="withdrawal-item">
            <div class="withdrawal-left">
              <span class="withdrawal-coin-badge">${w.coin}</span>
              <div class="withdrawal-info">
                <span class="withdrawal-amount">-${w.amount.toLocaleString(undefined, { maximumFractionDigits: 8 })} ${w.coin}</span>
                ${priceLabel ? `<span class="withdrawal-to">${priceLabel}</span>` : '<span class="withdrawal-to">Sent from wallet</span>'}
              </div>
            </div>
            <div class="withdrawal-right">
              <div class="withdrawal-date">${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} ${date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div>
              <div class="withdrawal-txid"><a href="${w.explorer}" target="_blank">${w.txid.slice(0, 12)}...${w.txid.slice(-6)}</a></div>
            </div>
          </div>
        `}).join('');
    }

    function updatePendingBurns() {
      const container = document.getElementById('pending-burns');
      
      // Wait for both withdrawals and burns to be loaded
      if (!withdrawalsLoaded || !burnDepositsLoaded) {
        return;
      }
      
      // If no data at all
      if (loadedWithdrawals.length === 0 && loadedBurnDeposits.length === 0) {
        container.innerHTML = `
          <div class="no-pending">
            <div class="all-burned-icon">üì≠</div>
            No withdrawal or burn data available
          </div>
        `;
        return;
      }
      
      // Convert withdrawals to USD using current prices
      const withdrawalsWithBalance = loadedWithdrawals.map(w => {
        const date = w.date instanceof Date ? w.date : new Date(w.date);
        const currentPrice = prices[w.coin] || 0;
        const usdValue = w.amount * currentPrice;
        return {
          ...w,
          date,
          usdValue,
          remainingUsd: usdValue, // Track how much hasn't been burned yet
          originalUsd: usdValue
        };
      }).sort((a, b) => a.date - b.date); // Sort oldest first
      
      // Convert burns to USD - only use 4 most recent burns
      // Use historical price (usdValueAtTime) if available, otherwise fall back to current price
      const quaiPrice = prices['QUAI'] || 0;
      const burnsWithUsd = loadedBurnDeposits.map(b => {
        const date = b.date instanceof Date ? b.date : new Date(b.date);
        // Prefer historical price, fall back to current price
        const usdValue = b.usdValueAtTime != null ? b.usdValueAtTime : (b.amount * quaiPrice);
        const usedHistoricalPrice = b.usdValueAtTime != null;
        return {
          ...b,
          date,
          usdValue,
          usedHistoricalPrice
        };
      }).sort((a, b) => b.date - a.date) // Sort newest first
        .slice(0, 4) // Only take 4 most recent burns
        .sort((a, b) => a.date - b.date); // Re-sort oldest first for processing
      
      console.log('=== Pending Burns Calculation ===');
      console.log('Withdrawals (oldest first):', withdrawalsWithBalance.map(w => 
        `${w.coin} $${w.usdValue.toFixed(2)} (current) @ ${w.date.toLocaleString()}`
      ));
      console.log('Burns (4 most recent, oldest first for processing):', burnsWithUsd.map(b => 
        `$${b.usdValue.toFixed(2)} ${b.usedHistoricalPrice ? '(historical)' : '(current)'} @ ${b.date.toLocaleString()}`
      ));
      
      // Process each burn - deduct from oldest withdrawals that happened BEFORE the burn
      for (const burn of burnsWithUsd) {
        let burnRemaining = burn.usdValue;
        
        console.log(`\nProcessing burn: $${burn.usdValue.toFixed(2)} @ ${burn.date.toLocaleString()}`);
        
        // Find withdrawals that happened before this burn and still have remaining balance
        for (const withdrawal of withdrawalsWithBalance) {
          if (burnRemaining <= 0) break;
          if (withdrawal.remainingUsd <= 0) continue;
          if (withdrawal.date >= burn.date) continue; // Only process withdrawals BEFORE this burn
          
          const deduction = Math.min(burnRemaining, withdrawal.remainingUsd);
          withdrawal.remainingUsd -= deduction;
          burnRemaining -= deduction;
          
          console.log(`  Deducted $${deduction.toFixed(2)} from ${withdrawal.coin} withdrawal, remaining: $${withdrawal.remainingUsd.toFixed(2)}`);
        }
        
        if (burnRemaining > 0) {
          console.log(`  Burn has $${burnRemaining.toFixed(2)} excess (more burned than withdrawn)`);
        }
      }
      
      // Find withdrawals that still have remaining balance (pending)
      const pendingWithdrawals = withdrawalsWithBalance
        .filter(w => w.remainingUsd > 0.01) // Small threshold for floating point
        .sort((a, b) => b.date - a.date); // Sort newest first for display
      
      console.log('\nPending withdrawals:', pendingWithdrawals.map(w => 
        `${w.coin} $${w.remainingUsd.toFixed(2)} remaining of $${w.originalUsd.toFixed(2)}`
      ));
      
      renderPendingBurnsUI(pendingWithdrawals, container);
    }

    function renderPendingBurnsUI(pendingWithdrawals, container) {
      // Calculate total pending
      const totalPendingUsd = pendingWithdrawals.reduce((sum, w) => sum + w.remainingUsd, 0);
      
      if (pendingWithdrawals.length === 0 || totalPendingUsd < 0.01) {
        container.innerHTML = `
          <div class="no-pending">
            <div class="all-burned-icon">‚úÖ</div>
            All tracked withdrawals have been burned!
          </div>
        `;
        return;
      }
      
      let html = `
        <div class="pending-header">
          <div class="pending-info">
            <div class="pending-label">
              <span class="pending-icon">‚è≥</span>
              Withdrawals Awaiting Burn
            </div>
            <div class="pending-subtitle">
              ${pendingWithdrawals.length} withdrawal${pendingWithdrawals.length !== 1 ? 's' : ''} not fully burned yet
            </div>
          </div>
          <div class="pending-total">
            <div class="pending-total-label">Total Pending</div>
            <div class="pending-total-amount">$${totalPendingUsd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
          </div>
        </div>
      `;
      
      html += pendingWithdrawals.map(w => {
        const isPartial = w.remainingUsd < w.originalUsd - 0.01;
        const burnedPercent = ((w.originalUsd - w.remainingUsd) / w.originalUsd * 100).toFixed(0);
        const priceSource = w.usedHistoricalPrice ? 'at time' : 'current';
        
        return `
          <div class="pending-item">
            <div class="pending-item-left">
              <span class="pending-badge">${w.coin}</span>
              <div class="pending-item-info">
                <span class="pending-amount">${w.amount.toLocaleString(undefined, { maximumFractionDigits: 8 })} ${w.coin}</span>
                <span class="pending-coin">
                  ${isPartial 
                    ? `$${w.remainingUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })} pending of $${w.originalUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })} (${burnedPercent}% burned, ${priceSource})`
                    : `$${w.originalUsd.toLocaleString(undefined, { maximumFractionDigits: 2 })} (${priceSource})`
                  }
                </span>
              </div>
            </div>
            <div class="pending-item-right">
              <div class="pending-date">${w.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} ${w.date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div>
              <div class="pending-status">${isPartial ? 'üî• Partially burned' : '‚è≥ Awaiting burn'}</div>
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = html;
    }

    async function fetchQuaiBalance(address) {
      const response = await fetch('https://rpc.quai.network/cyprus1/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'quai_getBalance',
          params: [address, 'latest'],
          id: 1
        })
      });
      const data = await response.json();
      if (data.result) {
        return parseInt(data.result, 16) / 1e18;
      }
      throw new Error('QUAI RPC failed');
    }

    async function fetchQuaiBlockNumber() {
      const response = await fetch('https://rpc.quai.network/cyprus1/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'quai_blockNumber',
          params: [],
          id: 1
        })
      });
      const data = await response.json();
      if (data.result) {
        return parseInt(data.result, 16);
      }
      throw new Error('Failed to get block number');
    }

    async function fetchQuaiBalanceAtBlock(address, blockHex) {
      const response = await fetch('https://rpc.quai.network/cyprus1/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'quai_getBalance',
          params: [address, blockHex],
          id: 1
        })
      });
      const data = await response.json();
      if (data.result) {
        return parseInt(data.result, 16) / 1e18;
      }
      return null;
    }

    async function fetchQuaiBalanceHistory(address, days) {
      const BLOCKS_PER_DAY = 17280;
      const targetDataPoints = 100; // How many points we want on the chart
      
      try {
        const currentBlock = await fetchQuaiBlockNumber();
        const totalBlocks = days * BLOCKS_PER_DAY;
        const startBlock = Math.max(1, currentBlock - totalBlocks);
        const stepSize = Math.max(90, Math.floor(totalBlocks / targetDataPoints));
        
        console.log(`Fetching history: currentBlock=${currentBlock}, startBlock=${startBlock}, stepSize=${stepSize}`);
        
        const historyData = [];
        let fetchCount = 0;
        
        // Fetch balances at intervals
        for (let block = startBlock; block <= currentBlock; block += stepSize) {
          const blockHex = '0x' + block.toString(16);
          const balance = await fetchQuaiBalanceAtBlock(address, blockHex);
          
          if (balance !== null) {
            // Estimate date based on block number
            const blocksFromNow = currentBlock - block;
            const msFromNow = (blocksFromNow / BLOCKS_PER_DAY) * 24 * 60 * 60 * 1000;
            const date = new Date(Date.now() - msFromNow);
            
            historyData.push({
              block: block,
              date: date.toISOString(),
              balance: balance
            });
          }
          
          fetchCount++;
          // Update loading status every 10 fetches
          if (fetchCount % 10 === 0) {
            const progress = Math.round((block - startBlock) / (currentBlock - startBlock) * 100);
            const loadingEl = document.getElementById(`chart-loading-${quaiWallets.find(w => w.address === address)?.exchange}`);
            if (loadingEl) loadingEl.innerHTML = `<div class="spinner" style="margin-right: 8px;"></div>Loading history... ${progress}%`;
          }
          
          // Small delay to avoid rate limiting
          await new Promise(r => setTimeout(r, 50));
        }
        
        console.log(`Fetched ${historyData.length} data points for ${address.slice(0,10)}`);
        return historyData;
      } catch (err) {
        console.error('Failed to fetch QUAI history:', err);
        return null;
      }
    }

    function createChart(exchange, historyData, days = 1) {
      const canvas = document.getElementById(`chart-${exchange}`);
      const loadingEl = document.getElementById(`chart-loading-${exchange}`);
      const infoEl = document.getElementById(`chart-info-${exchange}`);
      
      if (!historyData || !Array.isArray(historyData) || historyData.length === 0) {
        loadingEl.innerHTML = 'No historical data available';
        loadingEl.style.display = 'flex';
        canvas.style.display = 'none';
        if (infoEl) infoEl.textContent = '';
        return;
      }

      // Sort by date
      const sortedData = [...historyData].sort((a, b) => new Date(a.date) - new Date(b.date));

      if (sortedData.length === 0) {
        loadingEl.innerHTML = `No data available`;
        loadingEl.style.display = 'flex';
        canvas.style.display = 'none';
        if (infoEl) infoEl.textContent = '';
        return;
      }

      // Show date range info
      if (infoEl) {
        const firstDate = new Date(sortedData[0].date);
        const lastDate = new Date(sortedData[sortedData.length - 1].date);
        let dateFormat;
        if (days <= 1) {
          dateFormat = { hour: '2-digit', minute: '2-digit' };
        } else {
          dateFormat = { month: 'short', day: 'numeric' };
        }
        infoEl.textContent = `(${sortedData.length} points: ${firstDate.toLocaleString('en-US', dateFormat)} - ${lastDate.toLocaleString('en-US', dateFormat)})`;
      }

      loadingEl.style.display = 'none';
      canvas.style.display = 'block';

      const labels = sortedData.map(d => {
        const date = new Date(d.date);
        if (days <= 1) {
          return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        } else if (days <= 7) {
          return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit' });
        }
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });
      const values = sortedData.map(d => d.balance);

      if (quaiCharts[exchange]) quaiCharts[exchange].destroy();

      const pointRadius = sortedData.length <= 30 ? 3 : sortedData.length <= 60 ? 2 : sortedData.length <= 100 ? 1 : 0;

      quaiCharts[exchange] = new Chart(canvas, {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: 'Balance (QUAI)', data: values,
            borderColor: '#ff6666', backgroundColor: 'rgba(255, 102, 102, 0.1)',
            borderWidth: 2, fill: true, tension: 0.4,
            pointRadius: pointRadius, pointHoverRadius: 5,
            pointBackgroundColor: '#ff6666', pointHoverBackgroundColor: '#ff6666'
          }]
        },
        options: {
          responsive: true, maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: '#2a1010', borderColor: '#ff6666', borderWidth: 1,
              titleColor: '#ffffff', bodyColor: '#ffaaaa',
              callbacks: { label: ctx => `${ctx.parsed.y.toLocaleString(undefined, { maximumFractionDigits: 2 })} QUAI` }
            }
          },
          scales: {
            x: { grid: { color: 'rgba(255, 102, 102, 0.1)' }, ticks: { color: '#aa8888', font: { family: 'VT323', size: 12 }, maxTicksLimit: 8 } },
            y: { grid: { color: 'rgba(255, 102, 102, 0.1)' }, ticks: { color: '#aa8888', font: { family: 'VT323', size: 12 }, callback: v => v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(1)+'K' : v.toFixed(0) } }
          },
          interaction: { intersect: false, mode: 'index' }
        }
      });
    }

    async function fetchBalance(wallet) {
      const el = document.getElementById(`balance-${wallet.coin}`);
      const sourceEl = document.getElementById(`source-${wallet.coin}`);
      try {
        const result = await ({ RVN: fetchRVN, BCH: fetchBCH, LTC: fetchLTC, DOGE: fetchDOGE }[wallet.coin](wallet.address));
        balances[wallet.coin] = result.balance;
        const usdValue = result.balance * (prices[wallet.coin] || 0);
        el.innerHTML = `<p class="wallet-balance">${result.balance.toLocaleString(undefined, { maximumFractionDigits: 8 })}<span class="wallet-balance-coin">${wallet.coin}</span></p>
          <p class="wallet-usd">$${usdValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>`;
        sourceEl.textContent = `via ${result.source}`;
      } catch (err) {
        console.error(`Failed to fetch ${wallet.coin}:`, err);
        el.innerHTML = `<p class="wallet-error">FAILED TO LOAD</p>`;
        sourceEl.textContent = 'API error';
        balances[wallet.coin] = 0;
      }
    }

    async function fetchQuaiWalletData(wallet, days = 1, forceRefresh = false) {
      const el = document.getElementById(`quai-balance-${wallet.exchange}`);
      try {
        const balance = await fetchQuaiBalance(wallet.address);
        quaiBalances[wallet.exchange] = balance;
        const usdValue = balance * (prices['QUAI'] || 0);
        el.innerHTML = `<p class="wallet-balance">${balance.toLocaleString(undefined, { maximumFractionDigits: 4 })}<span class="wallet-balance-coin">QUAI</span></p>
          <p class="wallet-usd">$${usdValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p>`;
        
        // Check cache first
        let history = null;
        if (!forceRefresh) {
          history = getCachedHistory(wallet.exchange, days);
        }
        
        if (history) {
          quaiHistoryData[wallet.exchange] = history;
          createChart(wallet.exchange, history, days);
        } else {
          // Show loading for chart
          const loadingEl = document.getElementById(`chart-loading-${wallet.exchange}`);
          if (loadingEl) {
            loadingEl.style.display = 'flex';
            loadingEl.innerHTML = `<div class="spinner" style="margin-right: 8px;"></div>Loading history...`;
          }
          
          history = await fetchQuaiBalanceHistory(wallet.address, days);
          quaiHistoryData[wallet.exchange] = history;
          setCachedHistory(wallet.exchange, days, history);
          createChart(wallet.exchange, history, days);
        }
      } catch (err) {
        console.error(`Failed to fetch ${wallet.exchange} QUAI:`, err);
        el.innerHTML = `<p class="wallet-error">FAILED TO LOAD</p>`;
        quaiBalances[wallet.exchange] = 0;
        document.getElementById(`chart-loading-${wallet.exchange}`).innerHTML = 'Failed to load chart';
      }
    }

    function updateTotal() {
      let total = 0;
      wallets.forEach(w => total += (balances[w.coin] || 0) * (prices[w.coin] || 0));
      document.getElementById('total-usd').textContent = `$${total.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
      document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
    }

    async function fetchAllBalances(forceRefresh = false) {
      const btn = document.getElementById('refresh-btn'), icon = document.getElementById('refresh-icon'), text = document.getElementById('refresh-text');
      btn.disabled = true; icon.classList.add('spinning'); text.textContent = 'Loading...';
      
      // Reset loaded flags for pending burns calculation
      withdrawalsLoaded = false;
      burnDepositsLoaded = false;
      
      // Show loading state for pending burns
      document.getElementById('pending-burns').innerHTML = `
        <div class="loading-spinner" style="justify-content: center; padding: 20px;">
          <div class="spinner"></div>
          <span>Calculating pending burns...</span>
        </div>
      `;
      
      await fetchPrices();
      for (const wallet of wallets) { await fetchBalance(wallet); await new Promise(r => setTimeout(r, 400)); }
      
      // Update total immediately after crypto wallets load
      updateTotal();
      
      // Fetch withdrawals and burn deposits in background
      fetchAllWithdrawals(forceRefresh);
      fetchBurnDeposits(forceRefresh);
      
      for (const wallet of quaiWallets) { await fetchQuaiWalletData(wallet, selectedTimeRange[wallet.exchange] || 1); await new Promise(r => setTimeout(r, 400)); }
      
      updateTotal();
      btn.disabled = false; icon.classList.remove('spinning'); text.textContent = 'Refresh';
    }

    // Manual refresh button handler - forces cache bypass
    function manualRefresh() {
      resetRefreshCountdown();
      fetchAllBalances(true);
    }

    // Update burn refresh indicator
    function updateBurnRefreshIndicator() {
      const el = document.getElementById('burn-auto-refresh');
      if (el && lastBurnRefreshTime) {
        const timeStr = lastBurnRefreshTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        el.textContent = `(last: ${timeStr}, auto-refreshes every 5min)`;
      }
    }

    // Auto-refresh countdown
    const AUTO_REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes
    let nextRefreshTime = Date.now() + AUTO_REFRESH_INTERVAL;

    function resetRefreshCountdown() {
      nextRefreshTime = Date.now() + AUTO_REFRESH_INTERVAL;
    }

    function updateRefreshCountdown() {
      const remaining = Math.max(0, nextRefreshTime - Date.now());
      const minutes = Math.floor(remaining / 60000);
      const seconds = Math.floor((remaining % 60000) / 1000);
      const el = document.getElementById('next-refresh');
      if (el) {
        el.textContent = `Auto-refresh in ${minutes}:${seconds.toString().padStart(2, '0')}`;
      }
    }

    // Update countdown every second
    setInterval(updateRefreshCountdown, 1000);

    // Auto-refresh every 5 minutes
    setInterval(async () => {
      console.log('Auto-refreshing data...');
      resetRefreshCountdown();
      
      // Reset loaded flags
      withdrawalsLoaded = false;
      burnDepositsLoaded = false;
      
      // Show loading for pending burns
      document.getElementById('pending-burns').innerHTML = `
        <div class="loading-spinner" style="justify-content: center; padding: 20px;">
          <div class="spinner"></div>
          <span>Auto-refreshing...</span>
        </div>
      `;
      
      // Refresh burn deposits and withdrawals (force refresh to bypass cache)
      await Promise.all([
        fetchBurnDeposits(true),
        fetchAllWithdrawals(true)
      ]);
    }, AUTO_REFRESH_INTERVAL);

    renderWallets();
    renderQuaiWallets();
    fetchAllBalances();
  </script>
</body>
</html>
